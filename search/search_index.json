{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Moonlapse Tutorials","text":"<p>This site documents the Moonlapse project, including protocol, server, and client details.</p> <p>Use the navigation on the left to browse topics.</p>"},{"location":"00_build_modern_curses_mmo/","title":"\u00a700 Build a Modern Curses MMO with idiomatic, safe C++23","text":"<p>Welcome to the start of a hands-on series where we build a small multiplayer terminal game while learning the modern way to write C++23. If you already ship code in C, Go, or Python but feel uneasy about references, templates, or CMake files, this is for you. You will write real production-grade C++ as we go\u2014no toy examples\u2014and every concept earns its place in working code.</p> <p>We will grow a real project\u2014the <code>moonlapse_cpp</code> codebase\u2014step by step. Along the way you will learn how to:</p> <ul> <li>model packets and game state with strong types and value semantics,</li> <li>use RAII (Resource Acquisition Is Initialization) to keep sockets, threads, and terminal state safe,</li> <li>harness C++23 language and library features (concepts, <code>std::expected</code>, <code>std::jthread</code>, <code>&lt;print&gt;</code>),</li> <li>structure a CMake workspace that targets Linux and Windows with curses-based clients,</li> <li>keep server and client code testable and maintainable.</li> </ul> <p>This first instalment orients you, shows the tools we rely on, and highlights the C++ idioms you will meet repeatedly.</p> <p>Try this now: skim the repository root and open <code>shared/packets.hpp</code> in your editor. Notice how every type lives inside a namespace and avoids raw pointers. Keep that file open while you read; we will refer to it often.</p>"},{"location":"00_build_modern_curses_mmo/#1-big-picture-architecture","title":"1. Big-picture architecture","text":"<p><code>moonlapse_cpp</code> consists of three CMake targets. Each target compiles into its own executable or static library, but they share headers and idioms, just like a Go module with a shared package or a Rust workspace split into multiple crates.</p> <pre><code>project-root/\n\u251c\u2500 client/    # Terminal UI + input + client networking\n\u251c\u2500 server/    # Authoritative game state + broadcast\n\u2514\u2500 shared/    # Packets, protocol helpers, socket wrappers\n</code></pre> <p>The server listens for TCP connections, assigns players positions on a 2D grid, and broadcasts snapshots. The client is a curses-driven frontend that renders the grid and sends movement commands. The <code>shared</code> directory contains the protocol definitions and the networking abstraction we use on both sides.</p> <pre><code>##########################\n# @  o                 o #\n#                        #\n#           o            #\n##########################\nChat&gt; hello world_\n</code></pre> <p>That snapshot is the end goal for the first milestone: two terminals, one server, all state synchronized.</p> <p>Unlike the classic C style of sprinkling manual <code>malloc</code> and <code>free</code>, we let objects manage their own lifetimes. That principle (RAII) underpins everything in this series.</p>"},{"location":"00_build_modern_curses_mmo/#2-required-toolchain","title":"2. Required toolchain","text":"<p>You will need:</p> <ul> <li>A modern C++ compiler (Clang 17+, GCC 13+, or MSVC 2022) with full C++23 support.</li> <li>CMake \u2265 3.26.</li> <li><code>ncurses</code> (Linux/macOS) or PDCurses (Windows) for terminal rendering.</li> <li>A recent <code>clang-tidy</code> and <code>clang-format</code> to keep style consistent (optional but recommended).</li> </ul> <p>Install curses with your platform package manager:</p> <ul> <li>Ubuntu/Debian: <code>sudo apt-get install libncurses5-dev</code></li> <li>Fedora: <code>sudo dnf install ncurses-devel</code></li> <li>macOS (Homebrew): <code>brew install ncurses</code></li> <li>Windows: PDCurses is fetched automatically via CMake when you configure the project; ensure you generate either a Visual Studio or Ninja build.</li> </ul> <p>Clone the repository and generate a build tree:</p> <pre><code>cmake -S . -B build\ncmake --build build\n</code></pre> <p>If you are unsure about tool versions, double-check before the first configure step:</p> <pre><code>g++ --version\nclang++ --version\ncmake --version\n</code></pre> <p>On success you should see CMake finish with something like:</p> <pre><code>[100%] Linking CXX executable moonlapse_client\n[100%] Built target moonlapse_client\n</code></pre> <p>CMake uses out-of-source builds, so all generated files live inside <code>build/</code>. You can delete that directory at any time without touching your code.</p> <p>Why CMake? Because CMake is all about targets, not variables. Each module declares only what it consumes (<code>target_link_libraries(client PRIVATE moonlapse_shared Threads::Threads ${CURSES_LIBRARIES})</code>) and CMake handles include paths, definitions, and platform-specific switches.</p> <p>\u26a0\ufe0f Common configure issues</p> <ul> <li>Missing curses library: install the package listed above, then rerun <code>cmake -S . -B build</code>.</li> <li>Old compiler: GCC 13+ or Clang 17+ is required. On Ubuntu, <code>sudo apt-get install g++-13</code> and configure with <code>-DCMAKE_CXX_COMPILER=g++-13</code>.</li> <li>Windows SDK missing: ensure you ran the \u201cx64 Native Tools\u201d developer prompt before configuring.</li> </ul>"},{"location":"00_build_modern_curses_mmo/#3-a-modern-c-mindset","title":"3. A modern C++ mindset","text":"<p>Coming from C, Go, or Python, the most jarring differences in modern C++ are about ownership and expression. Modern C++ delivers deterministic memory safety without a garbage collector; RAII (Resource Acquisition Is Initialization) ensures resources release the moment they fall out of scope.</p>"},{"location":"00_build_modern_curses_mmo/#31-value-first-design","title":"3.1 Value-first design","text":"<p>In <code>shared/packets.hpp</code> you will see structs like:</p> <pre><code>struct MovementPacket {\n  PlayerId player{};\n  Direction direction{Direction::Up};\n};\n</code></pre> <p>This is plain old data, but we initialise members at the point of declaration and rely on aggregate initialisers (<code>MovementPacket packet{.player = id, .direction = dir};</code>). Values move efficiently when needed and copy when cheap. Value semantics make ownership explicit: you always know who owns what, and the compiler tells you when something is copied or moved.</p> <p>Move semantics in one sentence: when a type is cheap to move but expensive to copy (e.g., <code>std::vector</code>), C++ lets you transfer ownership instead of duplicating data by calling <code>std::move</code>\u2014the object on the right-hand side becomes \u201cmoved-from\u201d but remains valid. We will call this out whenever the codebase relies on moves for efficiency.</p>"},{"location":"00_build_modern_curses_mmo/#32-raii-everywhere","title":"3.2 RAII everywhere","text":"<p>Any resource\u2014socket, thread, window\u2014is wrapped in a type whose destructor releases it. For example, the client owns a <code>CursesSession</code>:</p> <pre><code>struct CursesSession {\n  CursesSession() : window{initscr()} { /* configure curses */ }\n  ~CursesSession() { if (active) endwin(); }\n  // ...\n};\n</code></pre> <p>Once the object goes out of scope, we are guaranteed that <code>endwin()</code> runs, even during exceptions. No manual <code>finally</code> blocks required. In Go you would <code>defer endwin()</code>; in C++ the destructor plays that role automatically at the end of scope, giving you Go-like determinism without a runtime or GC.</p>"},{"location":"00_build_modern_curses_mmo/#33-stdexpected-over-error-codes","title":"3.3 <code>std::expected</code> over error codes","text":"<p>Functions that can fail return <code>std::expected&lt;T, Error&gt;</code>. It behaves like Go\u2019s <code>(value, error)</code> multiple return values or Rust\u2019s <code>Result</code>, but the compiler enforces handling. The networking layer uses:</p> <pre><code>using SocketResult&lt;T&gt; = std::expected&lt;T, SocketError&gt;;\n</code></pre> <p>Callers inspect <code>.has_value()</code> or use the <code>if (!result) { /* handle */ }</code> pattern. Unlike exceptions, <code>std::expected</code> keeps control flow visible and local\u2014no invisible stack unwinding\u2014while still avoiding error-prone sentinel codes.</p> <pre><code>// Before (C-style):\nint send_packet(int sock, const void* data, size_t size);\nif (send_packet(fd, buffer, length) != 0) {\n  // who knows why it failed?\n}\n\n// After (std::expected):\nauto result = socket.sendAll(buffer);\nif (!result) {\n  std::println(\"send failed: {}\", result.error().message);\n}\n</code></pre>"},{"location":"00_build_modern_curses_mmo/#34-ranges-and-spans","title":"3.4 Ranges and spans","text":"<p>Where you might reach for raw pointer arithmetic in C, we reach for <code>std::span</code>. Think of it as C++\u2019s Go slice or Python\u2019s <code>memoryview</code>: a non-owning view over a contiguous block of memory. Packet decoding uses spans to iterate over byte buffers safely, and spans bridge nicely between STL containers and legacy C arrays.</p>"},{"location":"00_build_modern_curses_mmo/#4-cmake-primer-for-this-project","title":"4. CMake primer for this project","text":"<p>The top-level <code>CMakeLists.txt</code> declares the project standard and adds three subdirectories. Each subdirectory registers a target and its dependencies. Modern CMake is about targets, not variables: every target states what it needs and CMake wires the dependency graph. The key ideas:</p> <ul> <li><code>add_executable(moonlapse_client main.cpp)</code> defines a target.</li> <li><code>target_include_directories</code> lists include paths. Visibility matters: use <code>PRIVATE</code> for internal headers, <code>PUBLIC</code> when dependents also need them, and <code>INTERFACE</code> for headers only (no sources).</li> <li><code>target_link_libraries</code> pulls in the shared library, threading library, and curses vendor library\u2014again with <code>PRIVATE</code>/<code>PUBLIC</code> keywords to control propagation.</li> <li>Conditional blocks (<code>if (WIN32) ... else() ...</code>) let us link PDCurses on Windows and <code>ncurses</code> elsewhere.</li> </ul> <p>A minimalist client target looks like this:</p> <pre><code>add_executable(moonlapse_client main.cpp)\ntarget_link_libraries(moonlapse_client PRIVATE moonlapse_shared Threads::Threads ${CURSES_LIBRARIES})\ntarget_compile_features(moonlapse_client PRIVATE cxx_std_23)\n</code></pre> <p>Think of targets as modules. By keeping include paths and compile definitions private to a target, we avoid the global include soup you might remember from old CMake setups. If you come from Makefiles, think of this as a typed build graph where each node declares its needs explicitly.</p> <p>\ud83d\udee0\ufe0f Hands-on mini exercise</p> <ol> <li>Comment out the <code>target_link_libraries(moonlapse_client PRIVATE moonlapse_shared ...)</code> line in <code>client/CMakeLists.txt</code>.</li> <li>Run <code>cmake --build build</code>.</li> <li>Observe the link error complaining about missing protocol symbols.</li> <li>Restore the line and rebuild\u2014the error disappears. This is the core CMake feedback loop: targets declare dependencies and the build either succeeds or fails with precise diagnostics.</li> </ol>"},{"location":"00_build_modern_curses_mmo/#5-how-to-read-modern-c-code","title":"5. How to read modern C++ code","text":"<p>You will encounter syntax that looks alien at first glance. Here are the recurring patterns we will demystify in upcoming posts, along with rough translations to other languages:</p> Syntax Meaning Analogy Why it matters <code>auto main() -&gt; int</code> Trailing return type; stylistic Go function declarations Keeps complex return types readable <code>std::jthread receiver(...)</code> Joinable thread with cooperative stop Go goroutine + <code>context.Context</code> Ensures threads terminate when scope ends <code>std::scoped_lock guard{mutex};</code> RAII mutex guard Go <code>sync.Mutex</code> + <code>defer</code> Eliminates forgotten unlocks <code>std::variant</code> + <code>std::visit</code> Exhaustive sum type Rust <code>enum</code> with data Forces you to handle every packet kind <code>constexpr</code> values Compile-time constants <code>const</code> evaluated at compile time Eliminates runtime overhead <code>std::unique_ptr&lt;T&gt;</code> Exclusive owner with automatic cleanup Owning pointer + deterministic <code>defer close()</code> Prevents leaks without GC <p>If you keep function and type declarations narrow, C++ reads more like a strongly typed scripting language than the template jungle you may fear.</p>"},{"location":"00_build_modern_curses_mmo/#6-what-comes-next","title":"6. What comes next","text":"<p>The next post will set up the shared protocol headers from scratch. You will learn how to:</p> <ul> <li>model packets with strongly typed enums (<code>enum class</code>),</li> <li>implement safe encoding/decoding helpers with <code>std::span</code>,</li> <li>use <code>std::expected</code> to propagate errors without exceptions,</li> <li>unit-test packet logic by compiling only the <code>shared</code> target.</li> </ul> <p>From there we will flesh out the networking layer, build the curses UI, and eventually add features like chat, all while reinforcing modern C++ idioms.</p> <p>\ud83d\udea7 Common C++ pitfalls to watch for</p> <ul> <li>Forgetting <code>&amp;</code> in range-for loops (<code>for (auto player : players)</code> copies; use <code>auto&amp;</code> instead).</li> <li>Falling back to raw pointers\u2014reach for <code>std::unique_ptr</code>, <code>std::shared_ptr</code>, or <code>gsl::not_null</code> instead.</li> <li>Omitting <code>const</code> qualifiers, which can cause accidental mutations. Err on the side of <code>const</code> until mutation is required.</li> <li>Ignoring compiler warnings. Treat warnings as errors; the project enables high warning levels by default.</li> </ul> <p>Until then, explore the repository:</p> <pre><code># Build both client and server\ncmake --build build\n\n# Run the server\n./build/server/moonlapse_server\n\n# In another terminal, run the client\n./build/client/moonlapse_client\n</code></pre> <p>You now have a mental map of the playground. In \u00a701 we will write the protocol layer together, introduce templates and concepts where they earn their keep, and see how modern C++ expresses the same ideas you already know from other languages\u2014safely and succinctly.</p> <p>\ud83d\udcda Homework: run <code>cmake --build build --target moonlapse_shared</code>, then open <code>shared/packets.hpp</code> and identify every place <code>std::span</code> appears. Try explaining to yourself how each usage corresponds to a Go slice or Python <code>memoryview</code>. We will build on that understanding in the next chapter.</p>"},{"location":"01_shared_protocol/","title":"\u00a701 Stitching Together the Shared Protocol Layer","text":"<p>In \u00a700 you met the project layout, build tooling, and the modern C++ mindset we rely on. Now we immediately put that mindset to work by implementing the core that both the client and server must agree on: the protocol. We will design packet types, encode/decode helpers, and error handling inside the <code>shared/</code> module. By the end of this chapter you will have a clean, testable static library that both sides can link against.</p> <p>We will start small and iterate:</p> <ol> <li>Set up the <code>shared</code> target in CMake.</li> <li>Define fundamental domain types (player identifiers, directions, packet headers).</li> <li>Implement encoding helpers that serialize to network byte order using <code>std::byte</code> and <code>std::span</code>.</li> <li>Decode payloads safely with <code>std::expected</code> to surface errors without exceptions.</li> <li>Build and test the shared module independently.</li> </ol>"},{"location":"01_shared_protocol/#1-wire-up-the-shared-target-in-cmake","title":"1. Wire up the shared target in CMake","text":"<p>Create <code>shared/CMakeLists.txt</code> so the root <code>CMakeLists.txt</code> can <code>add_subdirectory(shared)</code>.</p> <pre><code>add_library(moonlapse_shared STATIC\n  packets.hpp\n)\n\nset_target_properties(moonlapse_shared PROPERTIES\n  CXX_STANDARD 23\n  CXX_STANDARD_REQUIRED ON\n  CXX_EXTENSIONS OFF\n)\n\ntarget_include_directories(moonlapse_shared PUBLIC\n  ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\n# Optional (recommended for installs): CMake 3.23+ can track installed headers explicitly.\n# target_sources(moonlapse_shared\n#   PUBLIC\n#     FILE_SET HEADERS\n#     BASE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}\n#     FILES packets.hpp\n# )\n\ntarget_compile_features(moonlapse_shared PUBLIC cxx_std_23)\n</code></pre> <p>A few things to notice:</p> <ul> <li><code>add_library(... STATIC \u2026)</code> gives us a static archive the client and server can link against.</li> <li>We set the standard requirements to C++23 explicitly (redundant with the top-level definition but harmless and self-documenting).</li> <li><code>target_include_directories(... PUBLIC \u2026)</code> makes the headers available to dependents without leaking extra search paths.</li> <li><code>target_compile_features(... PUBLIC cxx_std_23)</code> ensures any target that links against this one inherits the appropriate standard requirement.</li> <li>If you export or install the library, uncomment the <code>target_sources</code> block so CMake knows which headers belong to the target.</li> </ul> <p>Try it: run <code>cmake --build build --target moonlapse_shared</code> to make sure your CMake hierarchy is healthy before writing code. Right now the sources are empty, but once the files exist this target will build on its own.</p> <p>\ud83d\udee0\ufe0f Checkpoint: if the build fails here, double-check the new <code>add_library</code> line and confirm the root <code>CMakeLists.txt</code> includes <code>add_subdirectory(shared)</code>.</p>"},{"location":"01_shared_protocol/#2-establish-the-packet-scaffolding","title":"2. Establish the packet scaffolding","text":"<p>Create <code>shared/packets.hpp</code> and start with the essential includes, namespace, and type aliases. We lean heavily on <code>&lt;cstdint&gt;</code>, <code>&lt;span&gt;</code>, <code>&lt;expected&gt;</code>, and <code>&lt;array&gt;</code> from the standard library.</p> <pre><code>#pragma once\n\n#include &lt;array&gt;\n#include &lt;bit&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;expected&gt;\n#include &lt;span&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n\nnamespace Moonlapse::Protocol {\n\ninline constexpr std::uint16_t protocolVersion = 1;\ninline constexpr std::size_t packetHeaderSize =\n    sizeof(std::uint16_t) + sizeof(std::uint16_t) + sizeof(std::uint32_t);\n\nusing PlayerId = std::uint32_t;\n</code></pre>"},{"location":"01_shared_protocol/#why-inline-constexpr","title":"Why <code>inline constexpr</code>?","text":"<p>In a header we want a single definition across translation units. <code>inline constexpr</code> gives us a guaranteed ODR-safe constant. This is similar to a <code>const</code> global in Go but scoped inside the namespace.</p> <p>Concept note: <code>constexpr</code> values are evaluated at compile time. The compiler substitutes the literal values everywhere they are used, so there is zero runtime overhead.</p>"},{"location":"01_shared_protocol/#strong-enums-for-clarity","title":"Strong enums for clarity","text":"<p>Preferred enumerations use <code>enum class</code>. The scoped name avoids collisions and prevents implicit conversions.</p> <pre><code>enum class PacketType : std::uint8_t {\n  Movement = 1,\n  StateSnapshot = 2,\n};\n\nenum class Direction : std::uint8_t {\n  Up = 0,\n  Down = 1,\n  Left = 2,\n  Right = 3,\n};\n</code></pre> <p>Note that we specify the underlying type (<code>: std::uint8_t</code>) to control the byte layout on the wire. No magic numbers float around; each field matches the protocol spec.</p> <p>Add simple structs for positions and movement commands:</p> <pre><code>struct Position {\n  std::int32_t x{};\n  std::int32_t y{};\n};\n\nstruct MovementPacket {\n  PlayerId player{};\n  Direction direction{Direction::Up};\n};\n</code></pre> <p>We will add more packet types (e.g., state snapshots, chat) over time. For now this is enough to get the encoder/decoder pipeline in place.</p> <p>Close the namespace at the bottom of the file for now; we will keep appending to this header throughout the chapter.</p>"},{"location":"01_shared_protocol/#3-encoding-helpers-thinking-in-bytes","title":"3. Encoding helpers: thinking in bytes","text":"<p>When you talk to the network you have to convert structs into contiguous byte sequences. We want to perform this without dangerous pointer casting or manual buffer math. Enter <code>std::array&lt;std::byte, N&gt;</code> plus <code>std::span</code>.</p>"},{"location":"01_shared_protocol/#31-network-byte-order","title":"3.1 Network byte order","text":"<p>The protocol uses big-endian byte order. C++23\u2019s <code>&lt;bit&gt;</code> provides <code>std::byteswap</code> to help. Let\u2019s add two small helpers:</p> <pre><code>template &lt;std::integral T&gt;\n[[nodiscard]] constexpr auto toBigEndian(T value) noexcept -&gt; T {\n  if constexpr (std::endian::native == std::endian::big) {\n    return value;\n  }\n  return std::byteswap(value);\n}\n\ntemplate &lt;std::integral T&gt;\n[[nodiscard]] constexpr auto fromBigEndian(T value) noexcept -&gt; T {\n  return toBigEndian(value);\n}\n</code></pre> <p>These templates accept any integral type (<code>std::integral</code> is a C++20 concept) and either return the original value (on big-endian hosts) or byteswap (on little-endian machines like x86-64).</p> <p>Concept note: the <code>std::integral</code> concept keeps these helpers honest\u2014only integer-like types compile.</p> <p>Concept note: <code>[[nodiscard]]</code> asks the compiler to warn if you ignore the returned value, which is invaluable for functions that return converted data or <code>std::expected</code> objects.</p>"},{"location":"01_shared_protocol/#32-serializing-into-a-buffer","title":"3.2 Serializing into a buffer","text":"<p>Define a helper that writes integrals into an existing array. We design it with spans so it works with any buffer size\u2014<code>std::span</code> is the C++ equivalent of a Go slice or Python <code>memoryview</code>.</p> <pre><code>template &lt;std::integral T, std::size_t N&gt;\nvoid writeIntegral(std::array&lt;std::byte, N&gt;&amp; target, std::size_t&amp; offset,\n                   T value) noexcept {\n  auto networkOrder = toBigEndian(value);\n  auto bytes = std::bit_cast&lt;std::array&lt;std::byte, sizeof(T)&gt;&gt;(networkOrder);\n  auto destination =\n      std::span&lt;std::byte, N&gt;{target}.subspan(offset, bytes.size());\n  std::copy_n(bytes.begin(), bytes.size(), destination.begin());\n  offset += bytes.size();\n}\n\ntemplate &lt;std::integral T&gt;\n[[nodiscard]] inline auto readIntegral(std::span&lt;const std::byte&gt; buffer,\n                                       std::size_t&amp; offset)\n    -&gt; PacketResult&lt;T&gt; {\n  if (offset + sizeof(T) &gt; buffer.size()) {\n    return std::unexpected(PacketError::Truncated);\n  }\n\n  std::array&lt;std::byte, sizeof(T)&gt; raw{};\n  std::copy_n(buffer.begin() + static_cast&lt;std::ptrdiff_t&gt;(offset), sizeof(T),\n              raw.begin());\n  offset += sizeof(T);\n  return fromBigEndian(std::bit_cast&lt;T&gt;(raw));\n}\n</code></pre> <p>Callers pass a buffer and an offset by reference; the function writes the bytes and bumps the offset. No raw <code>char*</code> required.</p> <p>Concept note: <code>std::bit_cast</code> is the safe, constexpr alternative to <code>reinterpret_cast</code>. We bit-cast the integral into a byte array, copy the bytes, and let the compiler optimise away any temporaries.</p> <p>Why two APIs? The free functions keep header encoding simple, while <code>PayloadReader</code> manages its own offset when parsing payloads. Both rely on the same underlying idioms.</p>"},{"location":"01_shared_protocol/#33-encoding-the-packet-header","title":"3.3 Encoding the packet header","text":"<p>Every packet starts with a header describing version, type, and payload size. Add this struct and encoder:</p> <pre><code>struct PacketHeader {\n  std::uint16_t version{protocolVersion};\n  PacketType type{PacketType::Movement};\n  std::uint32_t payloadSize{};\n};\n\n[[nodiscard]] inline auto encodeHeader(PacketHeader header) noexcept\n    -&gt; std::array&lt;std::byte, packetHeaderSize&gt; {\n  std::array&lt;std::byte, packetHeaderSize&gt; buffer{};\n  std::size_t offset = 0;\n  writeIntegral(buffer, offset, header.version);\n  writeIntegral(buffer, offset, static_cast&lt;std::uint16_t&gt;(header.type));\n  writeIntegral(buffer, offset, header.payloadSize);\n  return buffer;\n}\n</code></pre>"},{"location":"01_shared_protocol/#34-payload-writer-utility","title":"3.4 Payload writer utility","text":"<p>For packet payloads we often need to append bytes dynamically. A small helper class that wraps <code>std::vector&lt;std::byte&gt;</code> keeps the code neat.</p> <pre><code>class PayloadWriter {\npublic:\n  template &lt;std::integral T&gt; void write(T value) {\n    auto networkOrder = toBigEndian(value);\n    auto bytes = std::bit_cast&lt;std::array&lt;std::byte, sizeof(T)&gt;&gt;(networkOrder);\n    m_buffer.insert(m_buffer.end(), bytes.begin(), bytes.end());\n  }\n\n  void writeByte(std::uint8_t value) {\n    m_buffer.push_back(static_cast&lt;std::byte&gt;(value));\n  }\n\n  [[nodiscard]] auto bytes() const noexcept -&gt; std::span&lt;const std::byte&gt; {\n    return m_buffer;\n  }\n\n  [[nodiscard]] auto release() &amp;&amp; -&gt; std::vector&lt;std::byte&gt; {\n    return std::move(m_buffer);\n  }\n\nprivate:\n  std::vector&lt;std::byte&gt; m_buffer;\n};\n</code></pre> <p>\ud83e\udde0 Concept note: <code>std::bit_cast</code> gives us a safe, constexpr way to treat bytes as another trivially copyable type. It replaces old <code>reinterpret_cast</code> hacks with defined behaviour.</p> <p>Notice that <code>release()</code> is an rvalue-qualified member; it returns the vector by move only when called on a temporary (<code>std::move(writer).release()</code>). This expresses ownership transfer clearly.</p> <p>Concept note: Move semantics let us transfer ownership without copying. After <code>std::move(writer)</code>, the writer keeps a valid but unspecified state while the caller takes over the buffer\u2014much like handing off a Go slice\u2019s backing array instead of cloning it.</p>"},{"location":"01_shared_protocol/#35-putting-it-together-encode-a-movement-command","title":"3.5 Putting it together: encode a movement command","text":"<p>Add this function to the header:</p> <pre><code>[[nodiscard]] inline auto encodePayload(const MovementPacket&amp; packet)\n    -&gt; std::vector&lt;std::byte&gt; {\n  PayloadWriter writer;\n  writer.write(packet.player);\n  writer.writeByte(static_cast&lt;std::uint8_t&gt;(packet.direction));\n  return std::move(writer).release();\n}\n\n[[nodiscard]] inline auto encode(const MovementPacket&amp; packet)\n    -&gt; std::vector&lt;std::byte&gt; {\n  auto payload = encodePayload(packet);\n  PacketHeader header{.type = PacketType::Movement,\n                      .payloadSize =\n                          static_cast&lt;std::uint32_t&gt;(payload.size())};\n  auto headerBytes = encodeHeader(header);\n\n  std::vector&lt;std::byte&gt; buffer;\n  buffer.reserve(packetHeaderSize + payload.size());\n  buffer.insert(buffer.end(), headerBytes.begin(), headerBytes.end());\n  buffer.insert(buffer.end(), payload.begin(), payload.end());\n  return buffer;\n}\n</code></pre> <p>We reserve capacity up front, append header then payload, and return a single buffer ready for sending over the socket.</p> <p>\ud83d\udee0\ufe0f Checkpoint: rebuild <code>moonlapse_shared</code> now. The target should compile without warnings. If you see template errors, they usually point to a missing include or a typo in the helper signatures.</p> <p>\ud83d\udd01 Round-trip demo: drop the snippet below into a scratch file (or a doctest case) to verify encoder/decoder symmetry.</p> <pre><code>const Protocol::MovementPacket original{\n  .player = 42,\n  .direction = Protocol::Direction::Down};\nauto encoded = Protocol::encode(original);\nauto header = Protocol::decodeHeader(std::span&lt;const std::byte&gt;{encoded});\nassert(header);\nauto payloadSpan =\n  std::span&lt;const std::byte&gt;{encoded}.subspan(Protocol::packetHeaderSize);\nauto decoded = Protocol::decodePacket(*header, payloadSpan);\nassert(decoded);\nauto* movement = std::get_if&lt;Protocol::MovementPacket&gt;(&amp;decoded.value());\nassert(movement != nullptr);\nassert(movement-&gt;player == original.player);\nassert(movement-&gt;direction == original.direction);\n</code></pre>"},{"location":"01_shared_protocol/#4-decoding-with-safety-guarantees","title":"4. Decoding with safety guarantees","text":"<p>Decoding is mirror work, but we must guard against truncated payloads or invalid data. This is where <code>std::expected</code> shines.</p>"},{"location":"01_shared_protocol/#41-packet-errors","title":"4.1 Packet errors","text":"<p>Define an enum for failure modes and a handy alias for <code>std::expected</code>:</p> <pre><code>enum class PacketError : std::uint8_t {\n  VersionMismatch,\n  UnknownType,\n  Truncated,\n  SizeMismatch,\n  InvalidPayload,\n};\n\ntemplate &lt;typename T&gt; using PacketResult = std::expected&lt;T, PacketError&gt;;\n\nUnlike `std::optional`, `std::expected` carries a strongly typed error. Callers can inspect `.error()` for the precise reason, keeping control flow explicit without exceptions.\n</code></pre>"},{"location":"01_shared_protocol/#42-reading-integrals-with-bounds-checking","title":"4.2 Reading integrals with bounds checking","text":"<p>Create a small reader that tracks offsets and returns <code>std::expected</code> when data runs out:</p> <pre><code>class PayloadReader {\npublic:\n  explicit PayloadReader(std::span&lt;const std::byte&gt; data) noexcept\n      : m_payload{data} {}\n\n  template &lt;std::integral T&gt; auto read() -&gt; PacketResult&lt;T&gt; {\n    if (m_offset + sizeof(T) &gt; m_payload.size()) {\n      return std::unexpected(PacketError::Truncated);\n    }\n\n    std::array&lt;std::byte, sizeof(T)&gt; raw{};\n    std::copy_n(m_payload.begin() + static_cast&lt;std::ptrdiff_t&gt;(m_offset),\n                sizeof(T), raw.begin());\n    m_offset += sizeof(T);\n    return fromBigEndian(std::bit_cast&lt;T&gt;(raw));\n  }\n\n  auto readByte() -&gt; PacketResult&lt;std::uint8_t&gt; { return read&lt;std::uint8_t&gt;(); }\n\n  [[nodiscard]] auto remaining() const noexcept -&gt; std::size_t {\n    return m_payload.size() - m_offset;\n  }\n\nprivate:\n  std::span&lt;const std::byte&gt; m_payload;\n  std::size_t m_offset{};\n};\n</code></pre> <p>No raw pointers, no undefined behaviour: either we return a successfully decoded value or we surface an error.</p>"},{"location":"01_shared_protocol/#43-header-decoding","title":"4.3 Header decoding","text":"<p>Reassemble the header carefully. Callers must check the error condition before using the result.</p> <pre><code>[[nodiscard]] inline auto decodeHeader(std::span&lt;const std::byte&gt; buffer)\n    -&gt; PacketResult&lt;PacketHeader&gt; {\n  if (buffer.size() &lt; packetHeaderSize) {\n    return std::unexpected(PacketError::Truncated);\n  }\n\n  std::size_t offset = 0;\n  auto version = readIntegral&lt;std::uint16_t&gt;(buffer, offset);\n  if (!version) {\n    return std::unexpected(version.error());\n  }\n\n  auto typeValue = readIntegral&lt;std::uint16_t&gt;(buffer, offset);\n  if (!typeValue) {\n    return std::unexpected(typeValue.error());\n  }\n\n  auto payloadSize = readIntegral&lt;std::uint32_t&gt;(buffer, offset);\n  if (!payloadSize) {\n    return std::unexpected(payloadSize.error());\n  }\n\n  if (*version != protocolVersion) {\n    return std::unexpected(PacketError::VersionMismatch);\n  }\n\n  auto decodedType = static_cast&lt;PacketType&gt;(*typeValue);\n  switch (decodedType) {\n  case PacketType::Movement:\n  case PacketType::StateSnapshot:\n    break;\n  default:\n    return std::unexpected(PacketError::UnknownType);\n  }\n\n  return PacketHeader{\n      .version = *version, .type = decodedType, .payloadSize = *payloadSize};\n}\n</code></pre> <p><code>readIntegral</code> here is a convenience wrapper identical in spirit to the <code>PayloadReader</code> implementation. You can either reuse the reader class or keep separate free functions\u2014the key point is that each conversion is bounds-checked and returns <code>std::expected</code>.</p> <p>Pattern reminder: checking <code>if (!result)</code> is the C++ analogue of Go\u2019s <code>if err != nil</code>. Use <code>return std::unexpected(result.error());</code> to propagate the failure immediately.</p>"},{"location":"01_shared_protocol/#44-decoding-a-movement-payload","title":"4.4 Decoding a movement payload","text":"<p>We validate each field and guard against unknown directions.</p> <pre><code>[[nodiscard]] inline auto decodeMovement(std::span&lt;const std::byte&gt; payload)\n    -&gt; PacketResult&lt;MovementPacket&gt; {\n  PayloadReader reader{payload};\n  auto playerId = reader.read&lt;PlayerId&gt;();\n  if (!playerId) {\n    return std::unexpected(playerId.error());\n  }\n\n  auto directionRaw = reader.readByte();\n  if (!directionRaw) {\n    return std::unexpected(directionRaw.error());\n  }\n\n  auto directionValue = *directionRaw;\n  if (directionValue &gt; static_cast&lt;std::uint8_t&gt;(Direction::Right)) {\n    return std::unexpected(PacketError::InvalidPayload);\n  }\n\n  if (reader.remaining() != 0) {\n    return std::unexpected(PacketError::SizeMismatch);\n  }\n\n  return MovementPacket{.player = *playerId,\n                        .direction = static_cast&lt;Direction&gt;(directionValue)};\n}\n</code></pre>"},{"location":"01_shared_protocol/#45-stitching-decoded-variants","title":"4.5 Stitching decoded variants","text":"<p>As the protocol grows, we will hold different packet structs inside a <code>std::variant</code>. For now it holds a single type, but wiring it up early keeps the interface stable.</p> <pre><code>using PacketVariant = std::variant&lt;MovementPacket&gt;;\n\n[[nodiscard]] inline auto decodePacket(const PacketHeader&amp; header,\n                                       std::span&lt;const std::byte&gt; payload)\n    -&gt; PacketResult&lt;PacketVariant&gt; {\n  if (payload.size() != header.payloadSize) {\n    return std::unexpected(PacketError::SizeMismatch);\n  }\n\n  switch (header.type) {\n  case PacketType::Movement: {\n    auto packet = decodeMovement(payload);\n    if (!packet) {\n      return std::unexpected(packet.error());\n    }\n    return PacketVariant{*packet};\n  }\n  default:\n    return std::unexpected(PacketError::UnknownType);\n  }\n}\n</code></pre> <p>When the enum gains additional entries, we expand both the variant and the switch statement. Exhaustive handling makes it impossible to \u201cforget\u201d a new packet type in one code path.</p> <p>Concept note: <code>std::variant</code> behaves like a Rust <code>enum</code> with data\u2014it stores exactly one alternative. <code>std::visit</code> forces you to handle every case, so the compiler catches missing packet handlers.</p> <p>\ud83e\udde0 Concept note: <code>std::variant</code> is a type-safe tagged union. Combined with <code>std::visit</code>, it enforces exhaustive handling at compile time.</p>"},{"location":"01_shared_protocol/#5-testing-the-shared-module-in-isolation","title":"5. Testing the shared module in isolation","text":"<p>Because <code>moonlapse_shared</code> is a static library with no outside dependencies, you can build and test it without touching the client or server. Two recommendations:</p> <ol> <li>Use <code>cmake --build build --target moonlapse_shared</code> during early development. This gives fast feedback whenever you change protocol code.</li> <li>Add a simple executable under <code>shared/tests/</code> driven by Catch2, doctest, or the testing framework of your choice. Point the new test target at <code>moonlapse_shared</code> to exercise encoding/decoding round-trips and edge cases.</li> </ol> <p>Example <code>CMakeLists.txt</code> snippet for a doctest-based test:</p> <pre><code>add_executable(shared_protocol_tests\n  tests/protocol_roundtrip.cpp\n)\n\ntarget_link_libraries(shared_protocol_tests PRIVATE moonlapse_shared)\n</code></pre> <p>Then run:</p> <pre><code>cmake --build build --target shared_protocol_tests\nctest --tests-regex shared_protocol\n</code></pre> <p>Even if you postpone formal tests for later, the standalone build target means you can iterate on <code>shared/</code> logic quickly with a single command. Great early tests include truncated headers, oversized payload declarations, and invalid direction codes to exercise each error branch.</p> <p>\ud83c\udfc1 Example doctest case</p> <pre><code>#include &lt;doctest/doctest.h&gt;\n#include \"packets.hpp\"\n\nTEST_CASE(\"movement packet round-trip\") {\n  using Protocol::Direction;\n  using Protocol::MovementPacket;\n\n  const MovementPacket original{.player = 7, .direction = Direction::Left};\n  auto encoded = Protocol::encode(original);\n  auto header = Protocol::decodeHeader(std::span&lt;const std::byte&gt;{encoded});\n  REQUIRE(header);\n  auto payloadSpan =\n      std::span&lt;const std::byte&gt;{encoded}.subspan(Protocol::packetHeaderSize);\n  auto decoded = Protocol::decodePacket(*header, payloadSpan);\n  REQUIRE(decoded);\n  REQUIRE(std::holds_alternative&lt;MovementPacket&gt;(decoded.value()));\n  const auto&amp; restored = std::get&lt;MovementPacket&gt;(decoded.value());\n  CHECK(restored.player == original.player);\n  CHECK(restored.direction == original.direction);\n}\n</code></pre> <p>Compile this under <code>shared/tests/</code> and you have executable assurance that the helpers behave.</p>"},{"location":"01_shared_protocol/#6-checklist","title":"6. Checklist","text":"<ul> <li>[x] <code>shared/CMakeLists.txt</code> defines a C++23 static library with clean include semantics.</li> <li>[x] Strongly typed enums describe packet types and directions.</li> <li>[x] Packet header encoding uses <code>std::byte</code> buffers and network byte order helpers.</li> <li>[x] <code>PayloadWriter</code> and <code>PayloadReader</code> encapsulate serialization without raw pointers.</li> <li>[x] <code>std::expected</code> communicates errors explicitly when decoding fails.</li> <li>[x] A <code>std::variant</code> keeps packet handling extensible.</li> </ul> <p>At this point, both client and server can include <code>packets.hpp</code>, encode movement commands, and decode them safely.</p>"},{"location":"01_shared_protocol/#whats-next-02","title":"What\u2019s next (\u00a702)","text":"<p>In the next chapter we will layer networking primitives on top of the protocol. \u00a702 introduces the cross-platform socket wrapper, showcases RAII for system handles, and demonstrates how to integrate <code>std::expected</code>-style error reporting with blocking/non-blocking I/O. By the end of \u00a702 you will be able to connect the client to the server and swap packets through the shared protocol you just built.</p>"},{"location":"02_networking_layer/","title":"\u00a702 Building the Networking Layer with RAII Sockets","text":"<p>In \u00a701 we modelled packets and proved the encode/decode pipeline. Now we have to move those octets across a wire. This chapter builds the cross-platform networking primitives that power both the server and the client. You will:</p> <ol> <li>wrap operating-system sockets in RAII-friendly C++23 classes,</li> <li>propagate failures with <code>std::expected</code>-style results instead of errno checks,</li> <li>implement blocking send/receive helpers that respect partial writes,</li> <li>compose those helpers inside the server accept loop and the client receiver thread.</li> </ol> <p>By the end you will understand every line of <code>shared/network.hpp</code> and how the higher-level modules rely on it.</p>"},{"location":"02_networking_layer/#1-shape-the-networking-surface-area","title":"1. Shape the networking surface area","text":"<p>We hide the platform details in a small namespace: <code>Moonlapse::Net</code>. Two public classes cover the entire socket lifecycle:</p> <ul> <li><code>TcpSocket</code> models a connected TCP endpoint (client side or accepted server connection).</li> <li><code>TcpListener</code> models a listening socket that can accept new clients.</li> </ul> <p>Both types follow RAII: their destructors close the underlying handle automatically. There is no way to leak a socket by forgetting to call <code>close()</code>.</p> <pre><code>namespace Moonlapse::Net {\n\nenum class SocketErrorCode : std::uint8_t {\n  None,\n  LibraryInitFailed,\n  ResolveFailed,\n  ConnectFailed,\n  BindFailed,\n  ListenFailed,\n  AcceptFailed,\n  SendFailed,\n  ReceiveFailed,\n  ConnectionClosed,\n  InvalidState,\n  WouldBlock,\n};\n\nstruct SocketError {\n  SocketErrorCode code{SocketErrorCode::None};\n  std::string message;\n  std::error_code system;\n};\n\ntemplate &lt;typename T&gt;\nusing SocketResult = std::expected&lt;T, SocketError&gt;;\n</code></pre> <p>The codecs live alongside the socket wrappers so every operation that can fail returns a <code>SocketResult&lt;T&gt;</code>. Callers must check the result; the compiler enforces it.</p>"},{"location":"02_networking_layer/#11-cross-platform-shims-live-in-detail","title":"1.1 Cross-platform shims live in <code>Detail</code>","text":"<p>The <code>Detail</code> namespace stores the platform glue: native handle typedefs, RAII deleters for <code>addrinfo</code>, helpers to convert pointer types, and wrappers that translate errno/<code>WSAGetLastError</code> into <code>std::error_code</code>. You never touch those from the client or server\u2014<code>TcpSocket</code> calls them internally.</p> <p>Key helpers include:</p> <ul> <li><code>resolveAddress(host, port, passive)</code> wraps <code>getaddrinfo</code>.</li> <li><code>makeError(code, context, nativeCode)</code> decorates a high-level <code>SocketError</code> with the OS message.</li> <li><code>ensureSocketLibrary()</code> runs <code>WSAStartup</code> on Windows once and registers <code>WSACleanup()</code> via <code>std::atexit</code>.</li> </ul> <pre><code>inline auto makeError(SocketErrorCode code, std::string_view context,\n                      int nativeCode = -1) -&gt; SocketError {\n  int effective = nativeCode &gt;= 0 ? nativeCode : lastErrorCode();\n  auto system = makeSystemError(effective);\n  std::string message(context);\n  if (effective != 0) {\n    message.append(\": \");\n    message.append(system.message());\n  }\n  return SocketError{.code = code, .message = std::move(message),\n                     .system = system};\n}\n</code></pre> <p>That little wrapper highlights the theme for the whole layer: grab the platform error, translate it into a portable <code>std::error_code</code>, and return an object the caller can inspect without touching errno directly.</p> <p>\ud83e\udde0 Concept note: <code>ensureSocketLibrary()</code> only does real work on Windows. It uses <code>std::call_once</code> to invoke <code>WSAStartup</code> exactly one time and registers <code>WSACleanup()</code> with <code>std::atexit</code>. On Linux and macOS the function returns immediately, but the call sites stay symmetric across platforms.</p> <p>The thin shims keep the public RAII classes small and readable.</p>"},{"location":"02_networking_layer/#2-tcpsocket-owned-connections-safe-sends","title":"2. <code>TcpSocket</code>: owned connections, safe sends","text":"<p><code>TcpSocket</code> owns a single connected handle. It is move-only to prevent accidental sharing. Construction uses factory functions:</p> <ul> <li><code>TcpSocket::connect(host, port)</code> for clients.</li> <li><code>TcpListener::accept()</code> for servers.</li> </ul> <pre><code>class TcpSocket {\npublic:\n  TcpSocket() noexcept = default;\n  explicit TcpSocket(NativeHandle nativeHandle) noexcept;\n  TcpSocket(TcpSocket&amp;&amp; other) noexcept;\n  auto operator=(TcpSocket&amp;&amp; other) noexcept -&gt; TcpSocket&amp;;\n  ~TcpSocket() { close(); }\n\n  [[nodiscard]] static auto connect(std::string_view host,\n                                    std::uint16_t port)\n      -&gt; SocketResult&lt;TcpSocket&gt;;\n\n  [[nodiscard]] auto send(std::span&lt;const std::byte&gt; buffer) const\n      -&gt; SocketResult&lt;std::size_t&gt;;\n  [[nodiscard]] auto sendAll(std::span&lt;const std::byte&gt; buffer) const\n      -&gt; SocketResult&lt;void&gt;;\n  [[nodiscard]] auto receive(std::span&lt;std::byte&gt; buffer) const\n      -&gt; SocketResult&lt;std::size_t&gt;;\n  [[nodiscard]] auto receiveExact(std::size_t byteCount) const\n      -&gt; SocketResult&lt;std::vector&lt;std::byte&gt;&gt;;\n\n  void shutdown() const noexcept;\n  void close() noexcept;\n  [[nodiscard]] auto isOpen() const noexcept -&gt; bool;\n};\n</code></pre> <p>\ud83e\udde0 Concept note: Methods such as <code>send(...) const</code> look odd if you come from Go or Python. In C++ <code>const</code> signals that the observable state of the object does not change\u2014writing to the socket is an external side effect, but the wrapper\u2019s data members stay untouched, so we can safely mark the method <code>const</code>.</p>"},{"location":"02_networking_layer/#21-deterministic-ownership-in-a-gc-free-world","title":"2.1 Deterministic ownership in a GC-free world","text":"<p>Go and Python developers normally lean on garbage collection or <code>defer</code> / context managers for cleanup. C++ has no GC, so RAII (Resource Acquisition Is Initialization) is how we guarantee deterministic destruction. When a <code>TcpSocket</code> instance leaves scope its destructor immediately calls <code>close()</code>, which in turn invokes <code>Detail::closeHandle</code>. There is no window where the operating system handle lingers because a collector has not run yet.</p> <p>Contrast: In Go you might write <code>defer conn.Close()</code> and trust the runtime to run it eventually. In this codebase, the compiler inserts the call at scope exit, so the handle closes even if we return early on error.</p> <pre><code>// C-style sockets demand manual cleanup on every exit path.\nint fd = socket(AF_INET, SOCK_STREAM, 0);\nif (fd == -1) { return -1; }\n// ... configure fd ...\nclose(fd); // must remember this for every return statement\n</code></pre> <p>RAII turns the closing logic into a destructor so every code path is covered without duplicated <code>close()</code> calls.</p>"},{"location":"02_networking_layer/#22-factory-functions-instead-of-raw-constructors","title":"2.2 Factory functions instead of raw constructors","text":"<p>The static <code>connect()</code> function hides the platform discovery (<code>getaddrinfo</code>), performs the OS call, and returns either a fully initialized socket or an error. A plain constructor cannot report failure, so we favour factory functions that return <code>SocketResult&lt;TcpSocket&gt;</code>. Callers spell <code>auto socket = TcpSocket::connect(...);</code> and must check the result before they obtain a usable object.</p>"},{"location":"02_networking_layer/#23-a-move-semantics-primer","title":"2.3 A move semantics primer","text":"<p>Sockets represent unique ownership: duplicating the handle would let two objects close it twice. We therefore delete copy operations and implement move-only behaviour:</p> <pre><code>TcpSocket(TcpSocket&amp;&amp; other) noexcept\n  : m_handle{std::exchange(other.m_handle, Detail::invalidSocketHandle)} {}\n\nauto operator=(TcpSocket&amp;&amp; other) noexcept -&gt; TcpSocket&amp; {\n  if (this != &amp;other) {\n    close();\n    m_handle =\n        std::exchange(other.m_handle, Detail::invalidSocketHandle);\n  }\n  return *this;\n}\n</code></pre> <p>\ud83e\udde0 Concept note: <code>std::exchange</code> swaps the current handle with <code>invalidSocketHandle</code> in one expression, leaving the moved-from object in a safe, closed state. That is the C++23 way to spell \u201ctake ownership and null out the source\u201d without manual <code>std::swap</code> plumbing.</p>"},{"location":"02_networking_layer/#24-blocking-sockets-and-partial-transfers","title":"2.4 Blocking sockets and partial transfers","text":"<p>TCP sockets are stream oriented. A single call to <code>send</code> or <code>recv</code> talks to the kernel, which may accept fewer bytes than requested because its internal buffer is full. We loop until the entire message is transferred:</p> <pre><code>[[nodiscard]] auto TcpSocket::sendAll(std::span&lt;const std::byte&gt; buffer) const\n    -&gt; SocketResult&lt;void&gt; {\n  std::size_t sentTotal = 0;\n  while (sentTotal &lt; buffer.size()) {\n    auto chunk = send(buffer.subspan(sentTotal));\n    if (!chunk) {\n      return std::unexpected(chunk.error());\n    }\n    if (chunk.value() == 0) {\n      return std::unexpected(\n          Detail::makeError(SocketErrorCode::ConnectionClosed, \"send\"));\n    }\n    sentTotal += chunk.value();\n  }\n  return {};\n}\n</code></pre> <p>Both <code>send()</code> and <code>receive()</code> retry automatically on interruptible errors such as <code>EINTR</code>. When the OS reports <code>EWOULDBLOCK</code>/<code>WSAEWOULDBLOCK</code> we bubble up <code>SocketErrorCode::WouldBlock</code>, which lets us extend the wrappers to non-blocking mode later.</p> <p>\ud83e\udde0 Concept note: Blocking I/O means the call parks the current thread until data is ready. <code>receiveExact(n)</code> will therefore wait for all <code>n</code> bytes or return an error if the peer disconnects. That predictability keeps the protocol code simple.</p>"},{"location":"02_networking_layer/#25-build-checkpoint","title":"2.5 Build checkpoint","text":"<p>\ud83d\udee0\ufe0f Checkpoint: After adding <code>TcpSocket</code> run <code>cmake --build build --target moonlapse_shared</code>. The target is header-only, but this quick build recompiles everything that includes <code>network.hpp</code> and ensures we did not miss an include or introduce a syntax error before wiring the listener.</p> <p>On failure every function returns <code>std::unexpected(SocketError{...})</code>. The server\u2019s accept loop logs <code>error.message</code>, and the client UI stores the string to show the user after curses shuts down.</p>"},{"location":"02_networking_layer/#3-tcplistener-raii-for-bindlisten","title":"3. <code>TcpListener</code>: RAII for <code>bind</code>/<code>listen</code>","text":"<p>Servers construct a listener, bind it to an address, and accept clients. <code>TcpListener</code> mirrors that lifecycle.</p> <pre><code>class TcpListener {\npublic:\n  [[nodiscard]] static auto bind(std::string_view host, std::uint16_t port)\n      -&gt; SocketResult&lt;TcpListener&gt;;\n  [[nodiscard]] auto listen(int backlog = SOMAXCONN) const\n      -&gt; SocketResult&lt;void&gt;;\n  [[nodiscard]] auto accept() const -&gt; SocketResult&lt;TcpSocket&gt;;\n\n  void close() noexcept;\n  [[nodiscard]] auto isOpen() const noexcept -&gt; bool;\n};\n</code></pre> <p>Design notes:</p> <ul> <li><code>bind()</code> runs <code>ensureSocketLibrary()</code>, resolves the host/port, enables <code>SO_REUSEADDR</code>, and returns a listener that owns the native handle.</li> <li><code>listen()</code> fails fast if you call it on a closed listener.</li> <li><code>accept()</code> wraps the platform call and returns a new <code>TcpSocket</code> already in RAII form.</li> </ul> <p>Ownership reminder: Just like <code>TcpSocket</code>, the listener\u2019s destructor calls <code>close()</code>, so the operating system port is released the moment the object leaves scope. No separate <code>defer</code> or <code>finally</code> block is required.</p> <p>\ud83e\udde0 Concept note: <code>SOMAXCONN</code> is the OS-defined upper bound for the pending connection queue. Passing it through preserves the platform default while still allowing explicit tuning later.</p> <p>This separation keeps the server\u2019s <code>main()</code> readable:</p> <pre><code>auto listenerResult = TcpListener::bind(\"0.0.0.0\", 40500);\nif (!listenerResult) {\n  std::println(\"[server] bind failed: {}\", listenerResult.error().message);\n  return 1;\n}\n\nauto listenerInstance = std::move(listenerResult.value());\nif (auto listenResult = listenerInstance.listen(); !listenResult) {\n  std::println(\"[server] listen failed: {}\", listenResult.error().message);\n  return 1;\n}\n</code></pre> <p>No manual cleanup is required\u2014the RAII wrapper closes the socket on scope exit even if an early <code>return</code> fires.</p> <p>\ud83d\udee0\ufe0f Checkpoint: Build just the server now with <code>cmake --build build --target moonlapse_server</code>. If it fails, double-check the new include order in <code>server/main.cpp</code> and ensure you added <code>#include \"network.hpp\"</code> from the shared module.</p>"},{"location":"02_networking_layer/#4-wiring-sockets-into-the-server-loop","title":"4. Wiring sockets into the server loop","text":"<p>Before the full game loop, sanity-check the wrappers with a minimal echo server. It accepts a single client, reads a header, and sends it straight back:</p> <pre><code>auto listenerResult = TcpListener::bind(\"127.0.0.1\", 40500);\nif (!listenerResult) {\n  throw std::runtime_error(listenerResult.error().message);\n}\nauto listener = std::move(listenerResult.value());\nlistener.listen().value();\nwhile (true) {\n  auto connection = listener.accept();\n  if (!connection) {\n    std::println(\"[demo] accept failed: {}\", connection.error().message);\n    continue;\n  }\n  auto socket = std::move(connection.value());\n  auto bytes = socket.receiveExact(Protocol::packetHeaderSize);\n  if (!bytes) {\n    std::println(\"[demo] read failed: {}\", bytes.error().message);\n    continue;\n  }\n  socket.sendAll(std::span&lt;const std::byte&gt;{bytes.value()}).value();\n}\n</code></pre> <p>The pattern is the same everywhere: call a helper, check the <code>std::expected</code>, and only use <code>.value()</code> once you are sure the call succeeded.</p> <p>\ud83e\uddea Try it: Drop that loop into a scratch executable under <code>server/tests/</code> if you want to watch <code>netcat</code> bounce packets back. It exercises both <code>receiveExact</code> and <code>sendAll</code> before we add concurrency.</p> <p>With the guardrails proven, the production <code>GameServer</code> thread-spawns <code>handleClient()</code> for every accepted connection:</p> <ol> <li>Receive a fixed-size header with <code>receiveExact(packetHeaderSize)</code>.</li> <li>Decode it using the \u00a701 protocol helpers.</li> <li>Allocate and receive the payload with <code>receiveExact(payloadSize)</code>.</li> <li>Visit the decoded variant and dispatch to movement, chat, or snapshot handlers.</li> </ol> <p>Every step checks the returned <code>SocketResult</code>. An error triggers a break, closing the socket and removing the player from the registry.</p> <p><code>TcpSocket</code> itself does not implement internal locking\u2014simultaneous <code>sendAll</code> calls from multiple threads would race on the underlying handle and interleave payloads. POSIX technically allows concurrent writes, but games want packet boundaries preserved, so we guard the send path with a <code>std::mutex</code>. The server wraps the socket inside a <code>Session</code> struct for that reason, while the global player table is protected by another mutex.</p> <p>\ud83e\udde0 Concept note: <code>std::scoped_lock</code> acquires every mutex passed to it and releases them automatically on scope exit. It is the multi-mutex, RAII-friendly successor to <code>std::lock_guard</code>.</p> <p>When broadcasting, we re-use the protocol encoder and the session wrapper:</p> <pre><code>void broadcastChat(const Protocol::ChatPacket&amp; chat) {\n  auto encoded = Protocol::encode(chat);\n  auto recipients = snapshotSessions();\n\n  for (const auto&amp; recipient : recipients) {\n    if (!recipient) {\n      continue;\n    }\n    if (auto result = recipient-&gt;send(std::span&lt;const std::byte&gt;{encoded});\n        !result) {\n      std::println(\"[server] chat broadcast failed for player {}: {}\",\n                   recipient-&gt;playerId, result.error().message);\n      removePlayer(recipient-&gt;playerId);\n    }\n  }\n}\n</code></pre> <p>Every failure becomes a structured <code>SocketError</code> with context. No raw errno checks clutter the gameplay code.</p> <p><code>snapshotSessions()</code> copies the shared pointers while holding the player mutex and releases the lock before sending, so long broadcasts never block new movement updates from being processed.</p> <p>\ud83e\udde0 Concept note: <code>std::visit</code> is the C++ equivalent of pattern-matching on a <code>std::variant</code>. The server builds an <code>Overloaded</code> helper (see <code>server/main.cpp</code>) so each lambda handles one packet alternative. Missing a case becomes a compile error the next time we extend <code>PacketVariant</code>.</p> <p>The receive loop also showcases idiomatic error propagation: <code>if (!result) return std::unexpected(result.error());</code> mirrors Go\u2019s <code>if err != nil { return err }</code> and keeps failure paths explicit without exceptions.</p>"},{"location":"02_networking_layer/#5-feeding-the-client-from-a-receiver-thread","title":"5. Feeding the client from a receiver thread","text":"<p>The client mirrors the server\u2019s read loop inside <code>receiverLoop</code> (a <code>std::jthread</code>):</p> <pre><code>void receiverLoop(const std::shared_ptr&lt;TcpSocket&gt;&amp; socket, ClientState&amp; state,\n                  std::atomic_bool&amp; running,\n                  std::atomic_bool&amp; connectionActive,\n                  std::mutex&amp; errorMutex, std::string&amp; lastError) {\n  while (running.load()) {\n    auto headerBytes = socket-&gt;receiveExact(Protocol::packetHeaderSize);\n    if (!headerBytes) {\n      std::scoped_lock guard{errorMutex};\n      lastError = headerBytes.error().message;\n      connectionActive.store(false);\n      running.store(false);\n      return;\n    }\n    // ... decode header, receive payload, std::visit the packet variant ...\n  }\n}\n</code></pre> <p>\ud83e\udde0 Concept note: <code>std::jthread</code> automatically joins in its destructor and exposes a <code>std::stop_token</code>. You no longer need to remember to call <code>join()</code> in every exit path\u2014the object handles cooperative shutdown for you.</p> <p>Because <code>TcpSocket</code> must stay alive while both the UI loop and the receiver loop run, we wrap it in <code>std::shared_ptr</code>. Neither thread is the clear \u201cowner,\u201d so shared ownership ensures the socket only closes once both references drop out of scope. We still guard the actual send path with a mutex; shared pointers manage lifetime, not thread safety.</p> <p>Analogy: In Go you might pass a pointer to a goroutine and trust the GC to keep it alive. In C++ we explicitly model shared lifetime with <code>std::shared_ptr</code>, and the runtime deletes the socket as soon as the last reference disappears.</p> <p>The receiver thread stops gracefully by observing an atomic <code>running</code> flag and by calling <code>receiver.request_stop()</code> when the main loop exits. Any error gets stored in <code>lastError</code> under a mutex, then shown in the UI after curses shuts down.</p> <p>On exit, the client shuts down and closes the socket explicitly. The destructor would run anyway, but calling <code>shutdown()</code> tells the peer that no more data will be sent, reducing the chance of lingering half-closed connections.</p>"},{"location":"02_networking_layer/#6-handling-errors-without-exceptions","title":"6. Handling errors without exceptions","text":"<p>The networking layer never throws. Every public method returns <code>SocketResult&lt;T&gt;</code>. Higher layers translate these into user-facing logs or UI messages.</p> <ul> <li>Server: <code>std::println(\"[server] accept failed: {}\", error.message);</code></li> <li>Client: stash the message in <code>lastError</code> and display it after curses tears down.</li> </ul> <p><code>SocketError</code> always carries three fields: a domain-specific <code>SocketErrorCode</code>, a human-readable message, and the original <code>std::error_code</code> for deeper inspection or logging. That keeps debugging straightforward\u2014especially useful when a failure happens on Windows but not on Linux.</p> <p>Why not just <code>std::error_code</code>? The extra enum lets higher layers branch on semantic states (e.g., <code>ConnectionClosed</code> vs <code>WouldBlock</code>) without parsing strings, while the embedded <code>std::error_code</code> preserves the OS-specific details for logs.</p>"},{"location":"02_networking_layer/#7-checklist-before-moving-on","title":"7. Checklist before moving on","text":"<ul> <li>[x] <code>shared/network.hpp</code> exposes <code>TcpSocket</code> and <code>TcpListener</code> as move-only RAII wrappers.</li> <li>[x] All networking functions return <code>SocketResult&lt;T&gt;</code> with rich error information.</li> <li>[x] Client and server use <code>receiveExact()</code> and <code>sendAll()</code> to avoid partial-transfer bugs.</li> <li>[x] Server sessions guard outgoing sends with a mutex; client guards chat/movement sends similarly.</li> <li>[x] Threads use <code>std::jthread</code> and atomic flags for cooperative shutdown.</li> </ul> <p>With packets and sockets in place the pipeline is complete: the server accepts clients, decodes movement commands, and broadcasts consistent snapshots; the client renders the shared state and relays chat. In \u00a703 we will turn to the terminal UI and input handling: rendering the grid, managing chat focus, and keeping the frame loop responsive without wasting CPU.</p>"},{"location":"03_authoritative_server/","title":"\u00a703 Orchestrating the Authoritative Server","text":"<p>With packets defined (\u00a701) and sockets wrapped in RAII (\u00a702), we can now run the game itself. This chapter turns those primitives into the living world loop on the server\u2014accepting clients, mutating state, and broadcasting authoritative snapshots. We will unpack <code>server/main.cpp</code> with three pillars:</p> <ol> <li>accepting clients and assigning sessions,</li> <li>mutating the shared world in response to movement/chat packets,</li> <li>broadcasting authoritative snapshots back to every player.</li> </ol> <p>The server enforces the rules of the room\u2014clients operate as thin terminals that render whatever the server says. Keeping the server authoritative prevents desyncs and cheats.</p>"},{"location":"03_authoritative_server/#concurrency-toolkit-refresher","title":"Concurrency toolkit refresher","text":"<p>We lean on a small set of modern C++23 concurrency primitives. If you come from Go or Python, here is the translation guide before diving in:</p> <ul> <li><code>std::shared_ptr&lt;T&gt;</code> \u2013 reference-counted shared ownership. Think of it as   an <code>Arc&lt;T&gt;</code> (Rust) or a ref-counted pointer; the object is destroyed when the   last owner drops it. We use it when two threads need to share a session safely.</li> <li><code>std::mutex</code> + <code>std::scoped_lock</code> \u2013 mutual exclusion. <code>std::scoped_lock</code>   acquires the mutex in its constructor and releases it in its destructor, so we   cannot forget to unlock\u2014even if an exception or early return occurs.</li> <li><code>std::atomic&lt;T&gt;</code> \u2013 a data race free integer. Calling <code>fetch_add(1)</code> is the   C++ equivalent of <code>atomic.AddInt32(&amp;value, 1)</code> in Go; every thread sees a   unique player identifier without explicit locking.</li> <li><code>std::jthread</code> \u2013 RAII-aware thread. Its destructor automatically joins or   requests stop, eliminating the \u201cforgot to join\u201d crashes that plagued   <code>std::thread</code>.</li> <li><code>std::variant</code> + <code>std::visit</code> \u2013 sum types with exhaustive visitors.   Combining them with the <code>Overloaded</code> helper lets us route packets to the   correct handler with compile-time checking.</li> </ul> <p>\ud83e\udde0 Concept note: We stick with blocking sockets plus a thread-per-connection model because it mirrors the platform-neutral abstractions from \u00a702 and keeps the code straightforward. Later chapters can swap in event loops or coroutine based IO without touching the gameplay logic.</p>"},{"location":"03_authoritative_server/#1-high-level-structure","title":"1. High-level structure","text":"<p><code>server/main.cpp</code> starts by importing the shared protocol and networking headers, then spins up a <code>GameServer</code> object.</p> <pre><code>using Moonlapse::Net::TcpListener;\nusing Moonlapse::Net::TcpSocket;\nnamespace Protocol = Moonlapse::Protocol;\n\nconstexpr std::uint16_t serverPort = 40500;\n\nauto main() -&gt; int {\n  constexpr std::string_view listenAddress = \"0.0.0.0\";\n  auto listenerResult = TcpListener::bind(listenAddress, serverPort);\n  if (!listenerResult) {\n    std::println(\"[server] bind failed: {}\", listenerResult.error().message);\n    return 1;\n  }\n\n  auto listenerInstance = std::move(listenerResult.value());\n  if (auto listenResult = listenerInstance.listen(); !listenResult) {\n    std::println(\"[server] listen failed: {}\", listenResult.error().message);\n    return 1;\n  }\n\n  std::println(\"[server] listening on {}:{}\", listenAddress, serverPort);\n  GameServer server{std::move(listenerInstance)};\n  server.run();\n  return 0;\n}\n</code></pre> <p>Everything interesting happens inside <code>GameServer</code>.</p> <ul> <li><code>TcpListener::bind()</code> and <code>listen()</code> come straight from \u00a702.</li> <li>We log and exit cleanly if the port is unavailable.</li> <li>Once the listener is ready, <code>GameServer::run()</code> enters an accept loop.</li> </ul> <p>\ud83e\udde0 Concept note: <code>constexpr std::string_view listenAddress</code> bakes the address into the binary at compile time. It behaves like a global constant in Go or a module-level constant in Python\u2014cheap to use and impossible to mutate accidentally.</p>"},{"location":"03_authoritative_server/#2-session-lifecycle","title":"2. Session lifecycle","text":"<p>Each connected player receives a <code>Session</code> object: a shared wrapper around a <code>TcpSocket</code> plus metadata. Sessions live inside <code>std::shared_ptr</code> because the accept loop, worker threads, and snapshot broadcasts all need to hold references.</p> <p>\ud83e\udde0 Concept note: <code>std::shared_ptr</code> keeps a reference count next to the object. Copying the pointer increments the count; destroying it decrements the count and deletes the session when it hits zero. This gives us garbage-collected style ownership semantics with deterministic destruction.</p> <pre><code>class GameServer {\npublic:\n  explicit GameServer(TcpListener listener) noexcept\n      : listener{std::move(listener)} {}\n\n  void run();\n\nprivate:\n  struct Session {\n    Session(Protocol::PlayerId playerIdentifier, TcpSocket&amp;&amp; socket) noexcept\n        : playerId{playerIdentifier}, socket{std::move(socket)} {}\n\n    auto send(std::span&lt;const std::byte&gt; payload) -&gt; SocketResult&lt;void&gt; {\n      std::scoped_lock guard{sendMutex};\n      return socket.sendAll(payload);\n    }\n\n    Protocol::PlayerId playerId;\n    TcpSocket socket;\n    std::mutex sendMutex;\n  };\n\n  // std::scoped_lock enters the critical section in its constructor and\n  // releases it automatically when the guard goes out of scope.\n\n  struct PlayerEntry {\n    Protocol::Position position;\n    std::shared_ptr&lt;Session&gt; session;\n  };\n\n  TcpListener listener;\n  std::atomic&lt;Protocol::PlayerId&gt; nextId{1};\n  mutable std::mutex playersMutex;\n  std::unordered_map&lt;Protocol::PlayerId, PlayerEntry&gt; players;\n  std::vector&lt;std::jthread&gt; workers;\n};\n</code></pre> <p>Key choices:</p> <ul> <li><code>Session::send()</code> guards the socket with a mutex because multiple threads (movement broadcasts, chat broadcasts) may write simultaneously.</li> <li>Worker threads live in a <code>std::vector&lt;std::jthread&gt;</code>. Thanks to RAII, the destructor joins them automatically when the server shuts down.</li> <li><code>mutable std::mutex playersMutex;</code> lets const-qualified helpers lock the map   even though they do not mutate observable state. It is similar to marking a   field as interiorly mutable in Rust.</li> </ul> <p>\ud83e\udde0 Concept note: <code>std::jthread</code> fixes the classic <code>std::thread</code> footgun: destroying an unjoined thread calls <code>std::terminate()</code>. With <code>std::jthread</code>, the destructor joins (or stop-requests) automatically, so even error paths shut down cleanly.</p> <p>\ud83e\udde0 Concept note: <code>std::make_shared&lt;Session&gt;(...)</code> allocates the control block and the session in one step. It is exception-safe and avoids the double allocation that <code>std::shared_ptr&lt;Session&gt;{new Session(...)}</code> would incur.</p>"},{"location":"03_authoritative_server/#21-accepting-clients","title":"2.1 Accepting clients","text":"<p><code>GameServer::run()</code> loops forever, calling <code>listener.accept()</code> for each connection. The accept loop stays on the main thread; each client runs on its own worker thread. This keeps networking responsive while the world map and player registry remain synchronised behind a single mutex. On success, we create a new session and hand it off to <code>registerPlayer()</code>.</p> <pre><code>void GameServer::run() {\n  std::println(\"[server] waiting for players...\");\n  while (true) {\n    auto connection = listener.accept();\n    if (!connection) {\n      std::println(\"[server] accept failed: {}\", connection.error().message);\n      continue;\n    }\n    registerPlayer(std::move(connection.value()));\n  }\n}\n</code></pre>"},{"location":"03_authoritative_server/#22-registering-a-player","title":"2.2 Registering a player","text":"<p><code>registerPlayer()</code> assigns a fresh identifier, chooses a spawn point, records the session, and sends the initial snapshot.</p> <pre><code>void GameServer::registerPlayer(TcpSocket socket) {\n  auto playerIdentifier = nextId.fetch_add(1);\n  auto session =\n      std::make_shared&lt;Session&gt;(playerIdentifier, std::move(socket));\n  auto position = spawnPosition(playerIdentifier);\n\n  {\n    std::scoped_lock guard{playersMutex};\n    players.emplace(playerIdentifier,\n                    PlayerEntry{.position = position, .session = session});\n  }\n\n  std::println(\"[server] player {} connected at ({}, {})\", playerIdentifier,\n               position.x, position.y);\n\n  if (auto snapshotResult = sendSnapshot(session, playerIdentifier);\n      !snapshotResult) {\n    std::println(\"[server] failed to initialize player {}: {}\",\n                 playerIdentifier, snapshotResult.error().message);\n    session-&gt;socket.shutdown();\n    session-&gt;socket.close();\n    removePlayer(playerIdentifier);\n    return;\n  }\n\n  broadcastState();\n\n  workers.emplace_back([this, session]() { handleClient(session); });\n}\n</code></pre> <p>Steps in order:</p> <ol> <li>Allocate ID: <code>nextId</code> is an <code>std::atomic</code>. Each new player increments it without data races.</li> <li>Spawn position: <code>spawnPosition()</code> spreads players across the grid without collisions by deriving coordinates from the ID.</li> <li>Store session: we grab <code>playersMutex</code>, insert state, and release the lock quickly.</li> <li>Send initial snapshot: the new player learns its ID and the current world.</li> <li>Notify everyone else: <code>broadcastState()</code> shares the updated roster.</li> <li>Launch worker thread: <code>handleClient()</code> runs in a dedicated <code>std::jthread</code>.</li> </ol> <p>If any step fails\u2014say, a socket write error\u2014the session tears down cleanly while the rest of the server keeps running.</p> <p>\ud83e\udde0 Concept note: <code>fetch_add(1)</code> on <code>std::atomic</code> is equivalent to Go\u2019s <code>atomic.AddUint32</code>. The operation is indivisible, so two threads can never hand out the same <code>PlayerId</code> even if they accept connections at the same moment.</p> <p>\ud83e\udde0 Concept note: <code>workers.emplace_back(...)</code> constructs the <code>std::jthread</code> in-place inside the vector, avoiding an extra move. It mirrors Rust\u2019s <code>vec.push(Thread::new(...))</code> but without temporary objects.</p> <pre><code>[[nodiscard]] auto GameServer::spawnPosition(Protocol::PlayerId playerIdentifier)\n    -&gt; Protocol::Position {\n  auto index = static_cast&lt;std::int32_t&gt;(playerIdentifier - 1);\n  auto x = index % gridWidth;\n  auto y = (index / gridWidth) % gridHeight;\n  return Protocol::Position{x, y};\n}\n</code></pre> <p>\ud83e\udde0 Concept note: The modulo arithmetic walks the grid row by row, ensuring every new player spawns on a distinct tile until the grid fills. The helper is pure math\u2014no locks required\u2014which keeps registration fast.</p>"},{"location":"03_authoritative_server/#23-threading-model-overview","title":"2.3 Threading model overview","text":"<pre><code>Main thread:\n  listener.accept() \u2192 registerPlayer()\n\nWorker thread (per player):\n  handleClient() \u2192 receive loop \u2192 handleMovement()/handleChat()\n</code></pre> <p>The <code>std::jthread</code> pool guarantees each worker joins automatically when the server shuts down, so we never leak threads.</p> <p>\u2696\ufe0f Design trade-off: A thread per connection keeps the walkthrough approachable and works well for dozens of players. At larger scales you would switch to an event loop (epoll/kqueue) or a pool of worker threads consuming a queue of socket jobs. The rest of the architecture\u2014sessions, protocol decoding, and broadcast helpers\u2014remains valid if you later adopt those models.</p>"},{"location":"03_authoritative_server/#3-handling-client-packets","title":"3. Handling client packets","text":"<p><code>handleClient()</code> performs the canonical read loop:</p> <pre><code>void GameServer::handleClient(const std::shared_ptr&lt;Session&gt;&amp; session) {\n  while (true) {\n    auto headerBytes =\n        session-&gt;socket.receiveExact(Protocol::packetHeaderSize);\n    if (!headerBytes) {\n      logSocketError(\"receive header\", session-&gt;playerId,\n                     headerBytes.error());\n      break;\n    }\n\n    auto headerResult =\n        Protocol::decodeHeader(std::span&lt;const std::byte&gt;{headerBytes.value()});\n    if (!headerResult) {\n      std::println(\"[server] packet header error for player {}: {}\",\n                   session-&gt;playerId,\n                   describePacketError(headerResult.error()));\n      break;\n    }\n\n    auto payloadBytes =\n        session-&gt;socket.receiveExact(headerResult-&gt;payloadSize);\n    if (!payloadBytes) {\n      logSocketError(\"receive payload\", session-&gt;playerId,\n                     payloadBytes.error());\n      break;\n    }\n\n    auto packetResult = Protocol::decodePacket(\n        *headerResult, std::span&lt;const std::byte&gt;{payloadBytes.value()});\n    if (!packetResult) {\n      std::println(\"[server] packet decode error for player {}: {}\",\n                   session-&gt;playerId,\n                   describePacketError(packetResult.error()));\n      break;\n    }\n\n    std::visit(Overloaded{\n                  [&amp;](const Protocol::MovementPacket&amp; movement) {\n                    handleMovement(session, movement);\n                  },\n                  [](const Protocol::StateSnapshotPacket&amp;) {\n                    // Clients never send snapshots back.\n                  },\n                  [&amp;](const Protocol::ChatPacket&amp; chat) {\n                    handleChat(session, chat);\n                  }},\n               *packetResult);\n  }\n\n  session-&gt;socket.shutdown();\n  session-&gt;socket.close();\n  removePlayer(session-&gt;playerId);\n  broadcastState();\n  std::println(\"[server] player {} disconnected\", session-&gt;playerId);\n}\n</code></pre> <p>Highlights:</p> <ul> <li><code>receiveExact()</code> and <code>decodeHeader()</code> come from earlier chapters.</li> <li>Each failure path logs context and breaks the loop; cleanup happens after the loop.</li> <li><code>Overloaded</code> is the standard helper pattern for visiting <code>std::variant</code> with lambdas.</li> </ul> <pre><code>template &lt;typename... Handlers&gt; struct Overloaded : Handlers... {\n  using Handlers::operator()...;\n};\n\ntemplate &lt;typename... Handlers&gt; Overloaded(Handlers...)\n    -&gt; Overloaded&lt;Handlers...&gt;;\n</code></pre> <p>\ud83e\udde0 Concept note: The helper inherits from each lambda and exposes all <code>operator()</code> overloads at once. Passing <code>Overloaded{...}</code> into <code>std::visit</code> mimics pattern-matching: the compiler checks that we handle every variant alternative.</p>"},{"location":"03_authoritative_server/#31-movement-handling","title":"3.1 Movement handling","text":"<p>Movement packets reflect the client\u2019s arrow-key input, but the server revalidates every command, clamps movement to the grid, and only trusts packets from the owning player.</p> <pre><code>void GameServer::handleMovement(const std::shared_ptr&lt;Session&gt;&amp; session,\n                                const Protocol::MovementPacket&amp; movement) {\n  if (movement.player != session-&gt;playerId) {\n    std::println(\"[server] ignoring spoofed movement for player {}\",\n                 session-&gt;playerId);\n    return;\n  }\n\n  bool updated = false;\n  {\n    std::scoped_lock guard{playersMutex};\n    auto entry = players.find(session-&gt;playerId);\n    if (entry == players.end()) {\n      return;\n    }\n    auto&amp; position = entry-&gt;second.position;\n    Protocol::Position previous = position;\n    applyMovement(position, movement.direction);\n    updated = previous.x != position.x || previous.y != position.y;\n  }\n\n  if (updated) {\n    broadcastState();\n  }\n}\n</code></pre> <ul> <li>Validation happens first\u2014anything spoofed gets logged and ignored.</li> <li>We take the lock, adjust the player\u2019s position via <code>applyMovement()</code>, and remember if anything changed.</li> <li>When the character moves, we broadcast a fresh snapshot to everyone.</li> </ul> <p>Movement uses helper functions:</p> <pre><code>[[nodiscard]] auto clampCoordinate(std::int32_t value, std::int32_t ceiling)\n    -&gt; std::int32_t {\n  if (value &lt; 0) {\n    return 0;\n  }\n  if (value &gt;= ceiling) {\n    return ceiling - 1;\n  }\n  return value;\n}\n\nvoid applyMovement(Protocol::Position&amp; position,\n                   Protocol::Direction direction) {\n  switch (direction) {\n  case Protocol::Direction::Up:\n    --position.y;\n    break;\n  case Protocol::Direction::Down:\n    ++position.y;\n    break;\n  case Protocol::Direction::Left:\n    --position.x;\n    break;\n  case Protocol::Direction::Right:\n    ++position.x;\n    break;\n  }\n\n  position.x = clampCoordinate(position.x, gridWidth);\n  position.y = clampCoordinate(position.y, gridHeight);\n}\n</code></pre> <p>These helpers keep the main handler tidy and express grid rules in one place.</p> <p>\ud83e\udde0 Concept note: <code>gridWidth</code> and <code>gridHeight</code> are compile-time constants at the top of <code>server/main.cpp</code>. Editing them instantly changes the playfield size for every new session.</p>"},{"location":"03_authoritative_server/#32-chat-handling","title":"3.2 Chat handling","text":"<p>Chat packets carry <code>{player, message}</code>. The server verifies the sender and rebroadcasts.</p> <pre><code>void GameServer::handleChat(const std::shared_ptr&lt;Session&gt;&amp; session,\n                            const Protocol::ChatPacket&amp; chat) {\n  if (chat.player != session-&gt;playerId) {\n    std::println(\"[server] ignoring spoofed chat for player {}\",\n                 session-&gt;playerId);\n    return;\n  }\n\n  broadcastChat(chat);\n}\n</code></pre> <p>Chat reuses the same send guard as movement broadcasts. Every packet travels through <code>Protocol::encode(chat)</code> before hitting the wire.</p>"},{"location":"03_authoritative_server/#4-broadcasting-authoritative-state","title":"4. Broadcasting authoritative state","text":"<p>Two broadcasting helpers keep the main logic compact:</p> <pre><code>void GameServer::broadcastState(Protocol::PlayerId focus = 0) {\n  auto snapshot = gatherSnapshot(focus);\n  auto encoded = Protocol::encode(snapshot);\n  auto recipients = snapshotSessions();\n\n  for (const auto&amp; recipient : recipients) {\n    if (!recipient) {\n      continue;\n    }\n    if (auto result = recipient-&gt;send(std::span&lt;const std::byte&gt;{encoded});\n        !result) {\n      std::println(\"[server] broadcast failed for player {}: {}\",\n                   recipient-&gt;playerId, result.error().message);\n      removePlayer(recipient-&gt;playerId);\n    }\n  }\n}\n\nvoid GameServer::broadcastChat(const Protocol::ChatPacket&amp; chat) {\n  auto encoded = Protocol::encode(chat);\n  auto recipients = snapshotSessions();\n\n  for (const auto&amp; recipient : recipients) {\n    if (!recipient) {\n      continue;\n    }\n    if (auto result = recipient-&gt;send(std::span&lt;const std::byte&gt;{encoded});\n        !result) {\n      std::println(\"[server] chat broadcast failed for player {}: {}\",\n                   recipient-&gt;playerId, result.error().message);\n      removePlayer(recipient-&gt;playerId);\n    }\n  }\n}\n</code></pre> <p>Future tweak: Both broadcast functions follow the same template by design\u2014encode, snapshot sessions, iterate. As the game grows you can extract a generic helper or introduce delta compression so idle players receive fewer bytes. For now the duplication keeps the walkthrough explicit.</p> <p>Supporting helpers gather state safely:</p> <pre><code>[[nodiscard]] auto GameServer::gatherSnapshot(Protocol::PlayerId focus) const\n    -&gt; Protocol::StateSnapshotPacket {\n  Protocol::StateSnapshotPacket snapshot{};\n  snapshot.focusPlayer = focus;\n\n  std::scoped_lock guard{playersMutex};\n  snapshot.players.reserve(players.size());\n  for (const auto&amp; [playerIdentifier, entry] : players) {\n    snapshot.players.emplace_back(\n        Protocol::PlayerState{playerIdentifier, entry.position});\n  }\n  return snapshot;\n}\n\n[[nodiscard]] auto GameServer::snapshotSessions() const\n    -&gt; std::vector&lt;std::shared_ptr&lt;Session&gt;&gt; {\n  std::vector&lt;std::shared_ptr&lt;Session&gt;&gt; sessions;\n  std::scoped_lock guard{playersMutex};\n  sessions.reserve(players.size());\n  for (const auto&amp; [playerIdentifier, entry] : players) {\n    sessions.push_back(entry.session);\n  }\n  return sessions;\n}\n</code></pre> <p>Design notes:</p> <ul> <li>We copy <code>shared_ptr</code> instances out of the map while holding the lock, then release the lock before performing network I/O. This avoids holding the mutex during potentially slow <code>send()</code> calls.</li> <li>The optional <code>focus</code> argument carries the joining player\u2019s ID so the client can highlight itself.</li> <li>If a send fails, we log and call <code>removePlayer()</code>.</li> </ul> <p>\ud83e\udde0 Concept note: Never hold a mutex while performing blocking I/O. The <code>snapshotSessions()</code> helper minimises lock duration: we grab the map, copy the <code>std::shared_ptr</code> handles, release the lock, and only then call <code>sendAll</code>. If a client stalls, the rest of the world keeps moving.</p>"},{"location":"03_authoritative_server/#41-removing-players-safely","title":"4.1 Removing players safely","text":"<pre><code>void GameServer::removePlayer(Protocol::PlayerId playerIdentifier) {\n  std::shared_ptr&lt;Session&gt; removed;\n  {\n    std::scoped_lock guard{playersMutex};\n    auto entry = players.find(playerIdentifier);\n    if (entry == players.end()) {\n      return;\n    }\n    removed = std::move(entry-&gt;second.session);\n    players.erase(entry);\n  }\n\n  if (removed) {\n    removed-&gt;socket.shutdown();\n    removed-&gt;socket.close();\n  }\n}\n</code></pre> <p>We grab the session pointer while locked, erase the map entry, then release the lock before shutting down the socket. This prevents deadlocks caused by calling into networking code while holding <code>playersMutex</code>.</p> <p>\ud83e\udde0 Concept note: Returning the <code>std::shared_ptr</code> outside the lock guarantees the session object stays alive until cleanup finishes\u2014even if other threads drop their copies during removal. Once every reference disappears, the RAII destructor runs and closes the socket one final time.</p>"},{"location":"03_authoritative_server/#5-error-logging-and-diagnostics","title":"5. Error logging and diagnostics","text":"<p>The server wraps socket errors in a helper to keep logs consistent:</p> <pre><code>static void GameServer::logSocketError(std::string_view action,\n                                       Protocol::PlayerId playerIdentifier,\n                                       const SocketError&amp; error) {\n  if (error.code == SocketErrorCode::ConnectionClosed) {\n    std::println(\"[server] player {} closed the connection\",\n                 playerIdentifier);\n    return;\n  }\n\n  std::println(\"[server] {} failed for player {}: {}\", action,\n               playerIdentifier, error.message);\n}\n</code></pre> <p><code>describePacketError()</code> translates <code>Protocol::PacketError</code> codes into strings, mirroring the client\u2019s UX. If decoding fails due to version mismatch or malformed payloads, we can see it instantly in the logs.</p>"},{"location":"03_authoritative_server/#6-try-it-now","title":"6. Try it now","text":"<p>\ud83d\udee0\ufe0f Build checkpoint:</p> <pre><code>cmake --build build --target moonlapse_server\n</code></pre> <p>Then launch the server from one terminal:</p> <pre><code>./build/server/moonlapse_server\n</code></pre> <p>From a second terminal run the <code>moonlapse_client</code> binary (you will build it in \u00a704; if you already compiled it, re-use that executable). Watch the server log as you connect, move, chat, and disconnect.</p> <p>\ud83d\udccb Sample log</p> <pre><code>[server] listening on 0.0.0.0:40500\n[server] waiting for players...\n[server] player 1 connected at (0, 0)\n[server] player 1 disconnected\n</code></pre> <p>Seeing the connect/disconnect messages proves the accept loop, session registration, and cleanup path are wired correctly.</p>"},{"location":"03_authoritative_server/#7-checklist","title":"7. Checklist","text":"<ul> <li>[x] <code>GameServer</code> owns the listener, player map, and worker threads.</li> <li>[x] Each player session guards its outgoing socket with a mutex.</li> <li>[x] Movement and chat handlers validate the sender before mutating state.</li> <li>[x] Snapshots broadcast the authoritative world after every change.</li> <li>[x] Player removal shuts down sockets outside the mutex to avoid deadlocks.</li> <li>[x] Logging distinguishes between clean disconnects and unexpected errors.</li> </ul> <p>With the server orchestrating the world, every movement and chat line flows through a single authority.</p> <pre><code>[Client A] \u2192\n             \\\n              [GameServer] \u2194 (Authoritative State)\n             /\n[Client B] \u2192\n</code></pre> <p>In \u00a704 we will switch perspectives to the client: rendering the grid with curses, managing chat focus, and coordinating the receiver thread with the input loop.</p>"},{"location":"04_curses_client/","title":"\u00a704 Crafting the Curses Client Frontend","text":"<p>With the server orchestrating the world (\u00a703) we now turn to the terminal client. This chapter shows how <code>client/main.cpp</code> knits together three threads of work:</p> <ol> <li>a curses front-end that renders the grid and chat log,</li> <li>an input loop that captures movement and chat commands,</li> <li>a receiver thread that hydrates local state from authoritative snapshots.</li> </ol> <p>Everything runs on top of the shared protocol (\u00a701) and networking layer (\u00a702), so the client stays thin\u2014no business logic, just presentation plus packet plumbing.</p>"},{"location":"04_curses_client/#1-bootstrapping-the-client-runtime","title":"1. Bootstrapping the client runtime","text":"<p>We start by connecting to the server, bringing up curses safely, and initialising the shared state objects that threads will share.</p> <pre><code>Main thread (UI &amp; input)\n  \u251c\u2500 polls getch(), sends packets, draws frames\nReceiver thread (std::jthread)\n  \u2514\u2500 blocks on receiveExact(), updates ClientState\n</code></pre> <pre><code>constexpr std::string_view serverAddress = \"127.0.0.1\";\nconstexpr std::uint16_t serverPort = 40500;\n\nauto main() -&gt; int {\n  auto socketResult = TcpSocket::connect(serverAddress, serverPort);\n  if (!socketResult) {\n    std::println(\"[client] failed to connect: {}\",\n                 socketResult.error().message);\n    return 1;\n  }\n\n  auto connection =\n      std::make_shared&lt;TcpSocket&gt;(std::move(socketResult.value()));\n  std::string lastError;\n\n  \ud83e\udde0 **Concept note:** The shared objects fall into four distinct roles. The\n  `std::shared_ptr&lt;TcpSocket&gt;` keeps the connection alive while both the input\n  loop and receiver thread use it. `ClientState` (protected by its internal mutex)\n  stores gameplay data that both threads read and write. Two\n  `std::atomic_bool` flags provide lock-free coordination for cooperative\n  shutdown, and `errorMutex` guards `lastError`, the string we surface to the\n  user after curses shuts down.\n\n  {\n    CursesSession curses;\n    if (!curses.active) {\n      std::println(\"[client] failed to initialize terminal UI\");\n      return 1;\n    }\n\n    ClientState state;\n    std::atomic_bool running{true};\n    std::atomic_bool connectionActive{true};\n    std::mutex errorMutex;\n    std::mutex sendMutex;\n\n    std::jthread receiver(receiverLoop, connection, std::ref(state),\n                          std::ref(running), std::ref(connectionActive),\n                          std::ref(errorMutex), std::ref(lastError));\n\n    ChatUiState chatState;\n    RuntimeContext runtime{sendMutex, errorMutex, lastError, running,\n                           connectionActive};\n\n    while (running.load()) {\n      if (!connectionActive.load()) {\n        break;\n      }\n\n      auto inputKey = getch();\n      if (handleInputKey(inputKey, chatState, connection, state, runtime) ==\n          LoopAction::Stop) {\n        break;\n      }\n\n      auto renderState = gatherRenderState(state);\n      drawFrame(renderState.snapshot, renderState.selfId,\n                std::span&lt;const ChatEntry&gt;{renderState.chatMessages},\n                chatState);\n      std::this_thread::sleep_for(refreshDelay);\n    }\n\n    running.store(false);\n    connectionActive.store(false);\n    receiver.request_stop();\n    receiver.join();\n\n    connection-&gt;shutdown();\n    connection-&gt;close();\n  }\n\n  if (!lastError.empty()) {\n    std::println(\"[client] {}\", lastError);\n  }\n\n  return 0;\n}\n</code></pre> <p>Highlights:</p> <ul> <li><code>TcpSocket::connect()</code> and the RAII shutdown mirror the server patterns.</li> <li><code>CursesSession</code> guards terminal state; leaving the scope tears down curses cleanly.</li> <li>Shared state lives in <code>ClientState</code>, guarded by a mutex.</li> <li>Atomic flags (<code>running</code>, <code>connectionActive</code>) coordinate the input loop with the receiver thread.</li> <li><code>RuntimeContext</code> bundles references so helpers can log errors and trigger shutdowns without globals.</li> <li><code>std::this_thread::sleep_for(refreshDelay)</code> yields the UI thread so we do not   busy-spin when no input arrives.</li> </ul> <p>\ud83e\udde0 Concept note: The shared objects fall into four distinct roles. The <code>std::shared_ptr&lt;TcpSocket&gt;</code> keeps the connection alive while both the input loop and receiver thread use it. <code>ClientState</code> (protected by its internal mutex) stores gameplay data that both threads read and write. Two <code>std::atomic_bool</code> flags provide lock-free coordination for cooperative</p> <pre><code>            \ud83e\udde0 **Concept note:** Curses exposes a process-wide singleton. Limiting\n            `CursesSession` to a single, non-movable owner guarantees `endwin()` runs at\n            most once\u2014even if an exception or early `return` occurs.\n</code></pre> <p>shutdown, and <code>errorMutex</code> guards <code>lastError</code>, the string we surface to the user after curses shuts down.</p> <p>\ud83e\udde0 Concept note: <code>std::ref(...)</code> wraps arguments in a reference wrapper so the <code>std::jthread</code> constructor passes the original object to <code>receiverLoop</code> instead of copying it. Without <code>std::ref</code>, the thread would see its own private copy of <code>ClientState</code>, <code>running</code>, and <code>lastError</code>, and changes would never make it back to the main loop.</p>"},{"location":"04_curses_client/#2-the-curses-session-as-raii","title":"2. The curses session as RAII","text":"<p>Curses requires matching <code>initscr()</code>/<code>endwin()</code> calls. We wrap that requirement in a move-proof RAII struct so the rest of the code can treat curses like any other resource.</p> <pre><code>struct CursesSession {\n  CursesSession() : window{initscr()} {\n    if (window == nullptr) {\n      return;\n    }\n    active = true;\n    cbreak();\n    noecho();\n    keypad(window, true);\n    nodelay(window, true);\n    curs_set(0);\n  }\n\n  ~CursesSession() {\n    if (active) {\n      endwin();\n    }\n  }\n\n  CursesSession(const CursesSession&amp;) = delete;\n  auto operator=(const CursesSession&amp;) -&gt; CursesSession&amp; = delete;\n  CursesSession(CursesSession&amp;&amp;) = delete;\n  auto operator=(CursesSession&amp;&amp;) -&gt; CursesSession&amp; = delete;\n\n  WINDOW* window{};\n  bool active{false};\n};\n</code></pre> <p>The constructor configures a non-blocking UI (<code>nodelay</code>) and disables echo so we can manage the cursor ourselves. The type is intentionally non-movable; owning the curses session twice would lead to double-shutdown bugs.</p>"},{"location":"04_curses_client/#3-local-state-and-render-pipeline","title":"3. Local state and render pipeline","text":"<p><code>ClientState</code> stores the authoritative snapshot as last received plus chat history. Rendering extracts immutable copies so we never hold the mutex during drawing.</p> <pre><code>struct ChatEntry {\n  Protocol::PlayerId player{};\n  std::string message;\n};\n\nstruct ChatUiState {\n  bool active{false};\n  std::string input;\n};\n\nstruct ClientState {\n  std::unordered_map&lt;Protocol::PlayerId, Protocol::Position&gt; players;\n  std::optional&lt;Protocol::PlayerId&gt; selfId;\n  std::deque&lt;ChatEntry&gt; chatLog;\n  mutable std::mutex mutex;\n};\n\nstruct RenderState {\n  std::vector&lt;Protocol::PlayerState&gt; snapshot;\n  std::vector&lt;ChatEntry&gt; chatMessages;\n  std::optional&lt;Protocol::PlayerId&gt; selfId;\n};\n\n\ud83e\udde0 **Concept note:** `std::optional` gives us an explicit \u201cmaybe\u201d value without\nresorting to sentinel IDs like `0` or `-1`. When `selfId` lacks a value, the\nclient simply has not received its focus packet yet.\n\n\ud83e\udde0 **Concept note:** We keep chat history in `std::deque` so pushing new entries\nand trimming old ones stay `O(1)` at both ends. Snapshots copy into\n`std::vector` because we iterate them linearly when drawing the grid.\n</code></pre> <p><code>gatherRenderState()</code> copies the data out under lock:</p> <pre><code>auto gatherRenderState(ClientState&amp; state) -&gt; RenderState {\n  RenderState render;\n  std::scoped_lock guard{state.mutex};\n\n  render.snapshot.reserve(state.players.size());\n  for (const auto&amp; [playerIdentifier, position] : state.players) {\n    render.snapshot.emplace_back(Protocol::PlayerState{\n        .player = playerIdentifier, .position = position});\n  }\n\n  render.chatMessages.reserve(state.chatLog.size());\n  for (const auto&amp; entry : state.chatLog) {\n    render.chatMessages.push_back(entry);\n  }\n\n  render.selfId = state.selfId;\n  return render;\n}\n\n\ud83e\udde0 **Concept note:** The render pipeline follows the *lock, copy, release*\npattern. We hold the mutex only long enough to snapshot the data, then draw from\nimmutable copies. Slow terminal I/O can never stall the receiver thread that\nkeeps `ClientState` fresh.\n</code></pre>"},{"location":"04_curses_client/#31-drawing-the-grid","title":"3.1 Drawing the grid","text":"<p>The draw helpers translate <code>RenderState</code> into curses calls. They are pure functions with no shared state, making them easy to reason about.</p> <pre><code>void drawBorder() {\n  for (int row = 0; row &lt;= gridHeight + 1; ++row) {\n    for (int column = 0; column &lt;= gridWidth + 1; ++column) {\n      const bool borderCell = row == 0 || row == gridHeight + 1 ||\n                              column == 0 || column == gridWidth + 1;\n      const auto glyph = static_cast&lt;unsigned char&gt;(borderCell ? '#' : ' ');\n      mvaddch(row, column, static_cast&lt;chtype&gt;(glyph));\n    }\n  }\n}\n</code></pre> <p><code>drawPlayers()</code> highlights the local player with <code>@</code> and renders others as <code>o</code>. The function clamps coordinates defensively in case future gameplay tweaks move players off-grid.</p> <pre><code>void drawPlayers(const std::vector&lt;Protocol::PlayerState&gt;&amp; snapshot,\n                 std::optional&lt;Protocol::PlayerId&gt; selfId) {\n  for (const auto&amp; player : snapshot) {\n    auto positionRow = static_cast&lt;int&gt;(player.position.y) + 1;\n    auto positionColumn = static_cast&lt;int&gt;(player.position.x) + 1;\n    if (positionColumn &lt; 1 || positionColumn &gt; gridWidth || positionRow &lt; 1 ||\n        positionRow &gt; gridHeight) {\n      continue;\n    }\n    const bool isSelf = selfId.has_value() &amp;&amp; player.player == *selfId;\n    const auto glyph = static_cast&lt;unsigned char&gt;(isSelf ? '@' : 'o');\n    mvaddch(positionRow, positionColumn, static_cast&lt;chtype&gt;(glyph));\n  }\n}\n</code></pre> <p>The rest of the UI is simple text: controls hint, player ID, chat log, and an input prompt with a trailing underscore when the chat box has focus. We assemble it all inside <code>drawFrame()</code>:</p> <pre><code>void drawFrame(const std::vector&lt;Protocol::PlayerState&gt;&amp; snapshot,\n               std::optional&lt;Protocol::PlayerId&gt; selfId,\n               std::span&lt;const ChatEntry&gt; chatMessages,\n               const ChatUiState&amp; chatUi) {\n  erase();\n  drawBorder();\n  drawPlayers(snapshot, selfId);\n  auto nextRow = drawInfoLines(selfId, chatUi);\n  nextRow = drawChatLog(nextRow, chatMessages);\n  drawChatPrompt(nextRow, chatUi);\n  refresh();\n}\n</code></pre> <p>Because curses is immediate-mode, we redraw the whole frame each tick. The <code>refreshDelay</code> constant (50 ms) throttles the loop to keep CPU usage reasonable.</p> <p>\ud83e\udde0 Concept note: Immediate-mode means the screen is just another buffer. Every frame we paint the full scene, then <code>refresh()</code> flushes it. All of the timing constants\u2014<code>gridWidth</code>, <code>gridHeight</code>, <code>refreshDelay</code>, and key codes like <code>escapeKeyCode</code>\u2014are defined near the top of <code>client/main.cpp</code> so tweaking the UI never requires hunting through the tutorial.</p> <p>The helper functions referenced here\u2014<code>drawInfoLines</code>, <code>drawChatLog</code>, <code>drawChatPrompt</code>, and the key constants\u2014live alongside the snippet in <code>client/main.cpp</code>. They are thin wrappers over curses primitives in the same style as <code>drawBorder()</code>.</p>"},{"location":"04_curses_client/#4-input-handling-and-packet-sends","title":"4. Input handling and packet sends","text":"<p>Input is split into two modes: movement (default) and chat (activated with the Enter key). We keep the logic modular with small helpers.</p> <pre><code>enum class LoopAction : std::uint8_t { Continue, Stop };\n\nauto handleInputKey(int inputKey, ChatUiState&amp; chatState,\n                    const std::shared_ptr&lt;TcpSocket&gt;&amp; connection,\n                    ClientState&amp; state, RuntimeContext&amp; runtime)\n    -&gt; LoopAction {\n  if (inputKey == ERR) {\n    return LoopAction::Continue;\n  }\n\n  if (chatState.active) {\n    return handleChatInputKey(inputKey, chatState, connection, state, runtime);\n  }\n\n  return handleMovementInputKey(inputKey, chatState, connection, state,\n                                runtime);\n}\n</code></pre>"},{"location":"04_curses_client/#41-movement-keys","title":"4.1 Movement keys","text":"<p>Arrow keys map to <code>Protocol::Direction</code> values. The helper sends a movement packet guarded by the shared <code>sendMutex</code>.</p> <pre><code>auto handleMovementInputKey(int inputKey, ChatUiState&amp; chatState,\n                            const std::shared_ptr&lt;TcpSocket&gt;&amp; connection,\n                            ClientState&amp; state, RuntimeContext&amp; runtime)\n    -&gt; LoopAction {\n  if (inputKey == 'q' || inputKey == 'Q') {\n    runtime.running.get().store(false);\n    return LoopAction::Stop;\n  }\n\n  if (inputKey == '\\n' || inputKey == KEY_ENTER) {\n    chatState.active = true;\n    chatState.input.clear();\n    return LoopAction::Continue;\n  }\n\n  if (auto direction = keyToDirection(inputKey); direction) {\n    if (auto result = sendMovement(connection, state, *direction,\n                                   runtime.sendMutex.get());\n        !result) {\n      const auto failureMessage = result.error().message;\n      recordSocketFailure(runtime, failureMessage);\n      return LoopAction::Stop;\n    }\n  }\n\n  return LoopAction::Continue;\n}\n</code></pre> <p><code>keyToDirection()</code> simply maps curses key constants (<code>KEY_UP</code>, etc.) to the protocol enum. The actual send is handled by <code>sendMovement()</code>:</p> <pre><code>auto sendMovement(const std::shared_ptr&lt;TcpSocket&gt;&amp; socket, ClientState&amp; state,\n                  Protocol::Direction direction, std::mutex&amp; sendMutex)\n    -&gt; SocketResult&lt;void&gt; {\n  std::optional&lt;Protocol::PlayerId&gt; playerIdentifier;\n  {\n    std::scoped_lock guard{state.mutex};\n    playerIdentifier = state.selfId;\n  }\n\n  if (!playerIdentifier) {\n    return {};\n  }\n\n  Protocol::MovementPacket packet{.player = *playerIdentifier,\n                                  .direction = direction};\n  auto encoded = Protocol::encode(packet);\n  std::scoped_lock guard{sendMutex};\n  return socket-&gt;sendAll(std::span&lt;const std::byte&gt;{encoded});\n}\n</code></pre> <p>We look up the local player ID under lock, build a packet, encode it with the shared protocol, and send it. If the ID is unknown (e.g., before the first snapshot arrives) the function returns early.</p> <p>\ud83e\udde0 Concept note: <code>RuntimeContext</code> is a lightweight bundle of references the handlers share. Passing one struct keeps the signatures tidy and avoids the global variables that are so common in traditional curses programs.</p>"},{"location":"04_curses_client/#42-chat-mode","title":"4.2 Chat mode","text":"<p>When chat mode is active, keystrokes append to the input string, handle backspace/delete, and submit with Enter.</p> <pre><code>auto handleChatInputKey(int inputKey, ChatUiState&amp; chatState,\n                        const std::shared_ptr&lt;TcpSocket&gt;&amp; connection,\n                        ClientState&amp; state, RuntimeContext&amp; runtime)\n    -&gt; LoopAction {\n  switch (inputKey) {\n  case escapeKeyCode:\n    chatState.active = false;\n    chatState.input.clear();\n    return LoopAction::Continue;\n  case '\\n':\n  case KEY_ENTER:\n    if (chatState.input.empty()) {\n      chatState.active = false;\n      return LoopAction::Continue;\n    }\n\n    if (auto result = sendChat(connection, state, chatState.input,\n                               runtime.sendMutex.get());\n        !result) {\n      const auto failureMessage = result.error().message;\n      recordSocketFailure(runtime, failureMessage);\n      return LoopAction::Stop;\n    }\n\n    chatState.input.clear();\n    chatState.active = false;\n    return LoopAction::Continue;\n  case KEY_BACKSPACE:\n  case deleteKeyCode:\n  case backspaceKeyCode:\n    if (!chatState.input.empty()) {\n      chatState.input.pop_back();\n    }\n    return LoopAction::Continue;\n  default:\n    if (inputKey &gt;= printableAsciiMin &amp;&amp; inputKey &lt;= printableAsciiMax &amp;&amp;\n        chatState.input.size() &lt; maxChatInputLength) {\n      chatState.input.push_back(static_cast&lt;char&gt;(inputKey));\n    }\n    return LoopAction::Continue;\n  }\n}\n</code></pre> <p><code>sendChat()</code> mirrors <code>sendMovement()</code>, encoding <code>Protocol::ChatPacket</code> and writing it under the send mutex. The chat log itself is capped at <code>maxChatMessages</code> to keep the UI tidy.</p>"},{"location":"04_curses_client/#5-receiver-thread-keeping-state-fresh","title":"5. Receiver thread: keeping state fresh","text":"<p><code>receiverLoop()</code> runs as a <code>std::jthread</code>, so its destructor requests stop automatically. The loop blocks on <code>receiveExact()</code> to pull headers and payloads from the server, then dispatches the decoded packets.</p> <pre><code>void receiverLoop(const std::shared_ptr&lt;TcpSocket&gt;&amp; socket, ClientState&amp; state,\n                  std::atomic_bool&amp; running, std::atomic_bool&amp; connectionActive,\n                  std::mutex&amp; errorMutex, std::string&amp; lastError) {\n  while (running.load()) {\n    auto headerBytes = socket-&gt;receiveExact(Protocol::packetHeaderSize);\n    if (!headerBytes) {\n      {\n        std::scoped_lock guard{errorMutex};\n        lastError = headerBytes.error().message;\n      }\n      connectionActive.store(false);\n      running.store(false);\n      return;\n    }\n\n    auto headerResult =\n        Protocol::decodeHeader(std::span&lt;const std::byte&gt;{headerBytes.value()});\n    if (!headerResult) {\n      {\n        std::scoped_lock guard{errorMutex};\n        lastError = std::string{describePacketError(headerResult.error())};\n      }\n      connectionActive.store(false);\n      running.store(false);\n      return;\n    }\n\n    auto payloadBytes = socket-&gt;receiveExact(headerResult-&gt;payloadSize);\n    if (!payloadBytes) {\n      {\n        std::scoped_lock guard{errorMutex};\n        lastError = payloadBytes.error().message;\n      }\n      connectionActive.store(false);\n      running.store(false);\n      return;\n    }\n\n    auto packetResult = Protocol::decodePacket(\n        *headerResult, std::span&lt;const std::byte&gt;{payloadBytes.value()});\n    if (!packetResult) {\n      {\n        std::scoped_lock guard{errorMutex};\n        lastError = std::string{describePacketError(packetResult.error())};\n      }\n      connectionActive.store(false);\n      running.store(false);\n      return;\n    }\n\n    std::visit(Overloaded{\n                  [&amp;](const Protocol::StateSnapshotPacket&amp; snapshot) {\n                    handleSnapshot(state, snapshot);\n                  },\n                  [](const Protocol::MovementPacket&amp;) {\n                    // Movement packets are redundant; snapshots carry state.\n                  },\n                  [&amp;](const Protocol::ChatPacket&amp; chat) {\n                    handleChat(state, chat);\n                  }},\n               *packetResult);\n  }\n}\n</code></pre> <p><code>Overloaded</code> is the same helper introduced in \u00a703\u2014it aggregates lambdas so <code>std::visit</code> can route each packet type to the correct handler with compile time checks.</p> <p>\ud83e\udde0 Concept note: The receiver thread performs blocking I/O on purpose. It owns the socket read-side exclusively, so parking on <code>receiveExact()</code> keeps the design simple. When data arrives we update <code>ClientState</code>; when shutdown starts, the main thread calls <code>shutdown()</code> to break the wait.</p> <p>Two helpers mutate <code>ClientState</code> under lock:</p> <pre><code>auto handleSnapshot(ClientState&amp; state,\n                    const Protocol::StateSnapshotPacket&amp; snapshot) -&gt; void {\n  std::unordered_map&lt;Protocol::PlayerId, Protocol::Position&gt; updated;\n  updated.reserve(snapshot.players.size());\n  for (const auto&amp; player : snapshot.players) {\n    updated.emplace(player.player, player.position);\n  }\n\n  std::scoped_lock guard{state.mutex};\n  state.players = std::move(updated);\n  if (snapshot.focusPlayer != 0) {\n    state.selfId = snapshot.focusPlayer;\n  }\n}\n\nauto handleChat(ClientState&amp; state, const Protocol::ChatPacket&amp; chat) -&gt; void {\n  ChatEntry entry{.player = chat.player, .message = chat.message};\n  std::scoped_lock guard{state.mutex};\n  state.chatLog.push_back(std::move(entry));\n  while (state.chatLog.size() &gt; maxChatMessages) {\n    state.chatLog.pop_front();\n  }\n}\n</code></pre> <p>Snapshots replace the entire position table to avoid drift. Chat messages append to a deque, trimming old entries once the cap is exceeded.</p>"},{"location":"04_curses_client/#51-handling-failures","title":"5.1 Handling failures","text":"<p>Any failure while receiving or decoding sets <code>lastError</code>, flips both atomic flags, and exits the loop. After curses shuts down, <code>main()</code> prints the final error (if any). This keeps the UI responsive even when the server disappears unexpectedly.</p> <p><code>recordSocketFailure()</code> provides the same failure path for send-side errors, so the whole runtime unwinds consistently.</p> <p>\ud83e\udde0 Concept note: Calling <code>connection-&gt;shutdown()</code> in <code>main()</code> wakes any thread blocked in <code>receiveExact()</code>. On POSIX it causes <code>recv()</code> to return <code>0</code> or <code>ECONNRESET</code>; on Windows it surfaces <code>WSAECONNRESET</code>. Either way the receiver thread notices, records the error, and stops without hanging.</p>"},{"location":"04_curses_client/#6-try-it-now","title":"6. Try it now","text":"<p>\ud83d\udee0\ufe0f Build checkpoint:</p> <pre><code>cmake --build build --target moonlapse_client\n</code></pre> <p>With the server from \u00a703 already running, launch the client:</p> <pre><code>./build/client/moonlapse_client\n</code></pre> <p>Use arrow keys to move, <code>Enter</code> to focus the chat box, type a short message, and press <code>Enter</code> again to send. <code>Esc</code> leaves chat mode, and <code>q</code> exits the client.</p> <p>\ud83d\udccb Sample log</p> <pre><code>[client] failed to connect: connection refused   # when the server is down\n[client] connection closed by peer               # when the server exits cleanly\n</code></pre> <p>Seeing movement echoed across two client windows confirms the receiver thread, shared state, and rendering pipeline are in sync.</p>"},{"location":"04_curses_client/#7-checklist","title":"7. Checklist","text":"<ul> <li>[x] <code>CursesSession</code> wraps terminal setup/teardown with RAII.</li> <li>[x] <code>ClientState</code> stores player positions, self ID, and chat history behind a mutex.</li> <li>[x] Rendering copies state snapshots under lock, then draws without holding the mutex.</li> <li>[x] Input loop supports movement, chat input, and quit semantics.</li> <li>[x] Movement and chat packets reuse the shared protocol encoders.</li> <li>[x] Receiver thread decodes authoritative snapshots and updates local state atomically.</li> <li>[x] Errors propagate through <code>RuntimeContext</code>, shutting down cleanly and reporting to the user.</li> </ul> <p>At this point the \u201cterminal MMO\u201d is fully playable: run the server, launch two clients, and watch the grid update in real time. In \u00a705 we will sew everything together with build/test workflows, plus suggestions for extending the game (animations, persistence, matchmaking, and beyond).</p>"},{"location":"05_ship_and_extend/","title":"\u00a705 Ship It and Extend It","text":"<p>We now have a functioning terminal MMO: protocol helpers (\u00a701), portable sockets (\u00a702), an authoritative server (\u00a703), and a curses client (\u00a704). This final chapter ties the project together with build/test tips, end-to-end run instructions, and ideas for expanding the game while keeping the codebase maintainable.</p>"},{"location":"05_ship_and_extend/#1-building-every-target","title":"1. Building every target","text":"<p>The root <code>CMakeLists.txt</code> wires together <code>shared</code>, <code>server</code>, and <code>client</code>. After configuring (<code>cmake -S . -B build</code>), rebuild everything with:</p> <pre><code>cmake --build build\n</code></pre> <p>Useful single-target builds when iterating locally:</p> <pre><code>cmake --build build --target moonlapse_shared\ncmake --build build --target moonlapse_server\ncmake --build build --target moonlapse_client\n</code></pre> <p>When <code>shared/packets.hpp</code> changes, rebuild the shared library first so dependent targets pick up new headers.</p>"},{"location":"05_ship_and_extend/#11-optional-compile-commands-for-tooling","title":"1.1 Optional: compile commands for tooling","text":"<p>The top-level <code>CMakeLists.txt</code> enables <code>CMAKE_EXPORT_COMPILE_COMMANDS</code>, so tools like clangd and clang-tidy can ingest <code>build/compile_commands.json</code> directly. This file is a universal manifest of compiler flags and include paths. Point VS\u00a0Code, CLion, or Neovim\u2019s clangd extension at it and you get accurate completions, diagnostics, and cross references without hand-maintaining settings\u2014a quality-of-life boost compared with the guesswork older C++ workflows required.</p>"},{"location":"05_ship_and_extend/#2-running-server-and-clients-together","title":"2. Running server and clients together","text":"<p>In separate terminals:</p> <pre><code>./build/server/moonlapse_server\n./build/client/moonlapse_client\n</code></pre> <p>The server logs connections, packet errors, and disconnects. Each client renders the grid, shows chat entries, and exits gracefully on <code>q</code>. You can run multiple clients from the same machine\u2014the server assigns unique IDs and positions using <code>spawnPosition()</code>.</p>"},{"location":"05_ship_and_extend/#21-verifying-end-to-end-behaviour","title":"2.1 Verifying end-to-end behaviour","text":"<p>Try this workflow after every major change:</p> <ol> <li>Start the server.</li> <li>Launch two clients.</li> <li>Move each avatar across the grid; confirm both screens update.</li> <li>Type chat messages in each client; confirm they appear in both logs.</li> <li>Close one client; verify the other still runs and the server logs the disconnect cleanly.</li> </ol> <p>Any failure should surface either in the server logs or in the client\u2019s terminal output after curses shuts down.</p>"},{"location":"05_ship_and_extend/#3-testing-strategy","title":"3. Testing strategy","text":"<p>We kept the runtime simple, but the architecture invites targeted tests:</p> <ul> <li>Shared protocol: add <code>shared/tests/protocol_roundtrip.cpp</code> and link against <code>moonlapse_shared</code>. Doctest or Catch2 work well. Focus on boundary cases: truncated headers, invalid directions, oversize chat payloads.</li> <li>Server logic: extract pure helpers (<code>applyMovement</code>, <code>spawnPosition</code>) into their own file for unit tests. For integration, consider spinning up the server in a test harness, then driving it with sockets using std::thread.</li> <li>Client render helpers: treat them as pure functions (they already are). If you want automated coverage, abstract the curses calls behind an interface so tests can assert on a fake framebuffer. For now, manual testing plus sanitizers is sufficient.</li> </ul> <p>Example doctest for the movement packet round-trip:</p> <pre><code>#include &lt;doctest/doctest.h&gt;\n#include \"packets.hpp\"\n\nTEST_CASE(\"movement packet round-trip\") {\n    using Protocol::Direction;\n    using Protocol::MovementPacket;\n\n    const MovementPacket original{.player = 42, .direction = Direction::Left};\n    auto encoded = Protocol::encode(original);\n    auto header = Protocol::decodeHeader(std::span&lt;const std::byte&gt;{encoded});\n    REQUIRE(header);\n    auto payload = std::span&lt;const std::byte&gt;{encoded}.subspan(Protocol::packetHeaderSize);\n    auto decoded = Protocol::decodePacket(*header, payload);\n    REQUIRE(decoded);\n    REQUIRE(std::holds_alternative&lt;MovementPacket&gt;(decoded.value()));\n    const auto &amp;restored = std::get&lt;MovementPacket&gt;(decoded.value());\n    CHECK(restored.player == original.player);\n    CHECK(restored.direction == original.direction);\n}\n</code></pre> <p>Drop this under <code>shared/tests/</code>, add a CMake target that links against <code>moonlapse_shared</code>, and wire it into CI so protocol regressions fail fast.</p>"},{"location":"05_ship_and_extend/#31-sanitizers-and-static-analysis","title":"3.1 Sanitizers and static analysis","text":"<p>Coming from Go or Python, the runtime guards you against use-after-free and buffer overflows. In C++ you lean on sanitizers instead\u2014they insert aggressive runtime checks that catch memory and UB bugs the moment they occur.</p> <p>Add an option near the top of your root <code>CMakeLists.txt</code>:</p> <pre><code>option(MOONLAPSE_ENABLE_SANITIZERS \"Enable address/UB sanitizers\" OFF)\nif(MOONLAPSE_ENABLE_SANITIZERS AND CMAKE_CXX_COMPILER_ID MATCHES \"Clang|GNU\")\n    add_compile_options(-fsanitize=address,undefined -fno-omit-frame-pointer)\n    add_link_options(-fsanitize=address,undefined)\nendif()\n</code></pre> <p>Then configure a dedicated build when you want the extra checks:</p> <pre><code>cmake -S . -B build-sanitize -DMOONLAPSE_ENABLE_SANITIZERS=ON -DCMAKE_BUILD_TYPE=Debug\ncmake --build build-sanitize\n</code></pre> <p>Pair that with <code>clang-tidy</code> (either via your editor or a dedicated CMake target) to flag stylistic or API usage issues before they reach <code>main</code>.</p>"},{"location":"05_ship_and_extend/#4-deployment-and-packaging","title":"4. Deployment and packaging","text":"<p>The server and client are single binaries with minimal dependencies:</p> <ul> <li>For Linux/macOS, ensure <code>ncurses</code> is installed (e.g., <code>apt-get install libncurses5-dev</code> or <code>brew install ncurses</code>).</li> <li>On Windows, bundle PDCurses (already handled in <code>client/CMakeLists.txt</code>) and ship the <code>.exe</code> alongside <code>pdcurses.dll</code> if necessary.</li> <li>Ship the server with a simple systemd service or a Docker container. Since the process is lightweight, a single core handles small rooms easily.</li> </ul> <p>When distributing builds, provide a README snippet with the same run commands from \u00a72.</p>"},{"location":"05_ship_and_extend/#5-where-to-go-next","title":"5. Where to go next","text":"<p>The architecture leaves plenty of room to grow. Stick to the shared protocol + RAII foundations and you can add features without fighting the existing code.</p>"},{"location":"05_ship_and_extend/#51-gameplay-ideas","title":"5.1 Gameplay ideas","text":"<ol> <li>Diagonals and speed: extend <code>Protocol::Direction</code> with diagonals; adjust <code>applyMovement()</code> accordingly.</li> <li>Persistent chat history: add a server-side ring buffer and send it in <code>StateSnapshotPacket</code> (remember to update the checklist in <code>.github/instructions/add_new_packet.instructions.md</code>).</li> <li>Rooms or channels: namespace players into rooms; include the room ID in movement/chat packets.</li> <li>NPCs or obstacles: treat non-player entities as extra entries in the snapshot, maybe with distinct glyphs.</li> </ol> <p>Each feature will touch the shared protocol, server dispatch, and client rendering\u2014use the packet checklist to stay consistent.</p> <p>That checklist lives in <code>.github/instructions/add_new_packet.instructions.md</code>. It walks through updating <code>PacketType</code>, encoding/decoding helpers, server dispatch, and client visitors so new wire formats stay synchronized across all three binaries.</p>"},{"location":"05_ship_and_extend/#52-networking-polish","title":"5.2 Networking polish","text":"<ul> <li>Non-blocking sockets: adjust <code>TcpSocket</code> to expose non-blocking mode and integrate polling (epoll/kqueue) for scaling past handfuls of clients.</li> <li>TLS support: wrap sockets with an mbedTLS or OpenSSL RAII layer.</li> <li>Heartbeat/ping: add a timer thread that sends heartbeat packets and drops idle clients.</li> </ul>"},{"location":"05_ship_and_extend/#53-testing-and-ci","title":"5.3 Testing and CI","text":"<p>Because the shared protocol, server helpers, and client rendering are decoupled, CI can exercise each layer independently. A minimal GitHub Actions workflow could:</p> <pre><code>name: ci\non: [push, pull_request]\njobs:\n    build:\n        runs-on: ubuntu-latest\n        steps:\n            - uses: actions/checkout@v4\n            - name: Configure\n                run: cmake -S . -B build\n            - name: Build\n                run: cmake --build build --target moonlapse_shared moonlapse_server moonlapse_client\n            - name: Protocol tests\n                run: ctest --test-dir build --output-on-failure\n</code></pre> <p>Layer on <code>clang-format</code>/<code>clang-tidy</code> steps or a sanitizer build as needed. The goal is to keep the protocol and state-management guarantees verifiable on every push, so feature work never silently drifts from the design we built in \u00a7\u00a701\u201304.</p>"},{"location":"05_ship_and_extend/#54-ui-improvements","title":"5.4 UI improvements","text":"<ul> <li>Color and animations: curses supports color pairs\u2014highlight the local player or chat mentions.</li> <li>Scrolling chat: increase <code>maxChatMessages</code> and add page-up/page-down navigation.</li> <li>Command palette: Adopt a slash-command system (<code>/nick</code>, <code>/whisper</code>, etc.) by extending the protocol.</li> </ul>"},{"location":"05_ship_and_extend/#6-what-you-learned","title":"6. What you learned","text":"<ul> <li>RAII wrappers (<code>TcpSocket</code>, <code>CursesSession</code>) give deterministic cleanup across     OS APIs, replacing manual <code>close()</code> calls.</li> <li><code>std::expected</code>, <code>std::variant</code>, and visitors keep protocol flows explicit and     type-safe.</li> <li>Thread ownership is spelled with <code>std::jthread</code>, <code>std::shared_ptr</code>, mutexes,     and atomics\u2014always pairing blocking I/O with clear lifetime rules.</li> <li>Modern CMake (targets, <code>compile_commands.json</code>, sanitizer toggles) removes the     friction of \u201cbig C++\u201d builds and makes IDE integration dependable.</li> </ul>"},{"location":"05_ship_and_extend/#7-checklist-recap","title":"7. Checklist recap","text":"<ul> <li>[x] Build instructions cover all targets and tooling hooks.</li> <li>[x] Runbook demonstrates the full server + multi-client workflow.</li> <li>[x] Testing guidance highlights shared protocol tests and sanitizer setup.</li> <li>[x] Deployment section notes platform dependencies.</li> <li>[x] Extension ideas map to concrete protocol/server/client changes.</li> </ul> <p>Thank you for following along. You now have a modern C++23 codebase that demonstrates RAII, safe networking, and a curses UI working in concert. Keep the packet checklist handy, lean on <code>std::expected</code> when adding error paths, and continue building features one module at a time. Happy hacking! </p>"}]}